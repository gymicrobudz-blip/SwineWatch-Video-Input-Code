import cv2
import numpy as np
import time
import os
import cloudinary
import cloudinary.uploader
from tflite_runtime.interpreter import Interpreter
from picamera2 import Picamera2
import serial
import firebase_admin
from firebase_admin import credentials, db
from flask import Flask, Response
import threading
import re
from filterpy.kalman import KalmanFilter
from flask import request

# ================= FIREBASE =================
cred = credentials.Certificate(
    "/home/asfrotect/Projects/BYMS_TFLITE_3_COMBINED/firebase.json"
)
if not firebase_admin._apps:
    firebase_admin.initialize_app(cred, {
        "databaseURL": "https://asfrotect-default-rtdb.asia-southeast1.firebasedatabase.app/"
    })

# ================= CLOUDINARY =================
cloudinary.config(
    cloud_name="dmjhw3xa2",
    api_key="518441677687474",
    api_secret="uWQqwVKVN7QZ_AcU5dWy4htZvR0",
    secure=True
)

# ================= THERMAL =================
try:
    import board
    import busio
    import adafruit_mlx90640
    from matplotlib import cm
    THERMAL_AVAILABLE = True
except Exception as e:
    print("Thermal not available:", e)
    THERMAL_AVAILABLE = False

# ================= PERFORMANCE =================
cv2.setNumThreads(0)
cv2.ocl.setUseOpenCL(False)

# ================= CONFIG =================
INPUT_SIZE = 416
INTERVAL_MODE = "hour"
INTERVAL_VALUE = 1
SAVE_ROOT = "/home/asfrotect/Desktop/detections"
PI_CAM_FPS = 0.0

# ================= RESOLUTION LOCK =================
CAM_W = 640
CAM_H = 480
SMALL_W = CAM_W // 2   # 320 when CAM_W = 640

THERMAL_W = CAM_W
THERMAL_H = CAM_H

STREAM_W = 1280
STREAM_H = 720

# ================= FPS TRACKING =================
thermal_fps = 0.0
last_thermal_frame_ts = None

THERMAL_MIN_TEMP = 0.0
THERMAL_MAX_TEMP = 0.0
THERMAL_AVG_TEMP = 0.0

# ================= INFERENCE FLAGS =================
DRAW_PIG_BOXES = True     # Only affects visualization
DRAW_BEHAVIOR_LABEL = True
DRAW_SKIN_BOXES = True

SHOW_OPENCV_WINDOW = False

# ===== ASF PER-PIG TRACKING =====
asf_pigs_hourly = {}   # hour_key -> set(pig_id)
# ================= MONITORED PIGS =================
monitored_pigs_daily = {}   # date -> set(pig_id)

# ================= FEVER HISTORY =================
fever_hourly = {}  # hour_key -> True/False
# ================= PERSISTENT HISTORY =================
lesion_hourly = {}     # hour_key -> True/False
# ================= HOURLY BEHAVIOR COUNTS =================
behavior_counts_hourly = {}  # hour_key -> { "ACTIVE": set(pig_id), ... }

# ================= FEVER PERSISTENCE =================
FEVER_PERSIST_HOURS = 3   # X hours (change as needed)
# --- GLOBAL (add once) ---
thermal_ema = None
THERMAL_ALPHA = 0.2  # temporal smoothing (0.1ÃƒÂ¯Ã‚Â¿Ã‚Â½0.3)

thermal_hourly_samples = {}  # hour_key -> list of temps
gsm_initialized = False

# ================= MODELS ===Projects==============
PIG_MODEL = "/home/asfrotect/Projects/BYMS_TFLITE_3_COMBINED/PigvsNONPig-v2_float16.tflite"
BEHAVIOR_MODEL = "/home/asfrotect/Projects/BYMS_TFLITE_3_COMBINED/LucbanBehaviorV2_int8.tflite"
SKIN_MODEL = "/home/asfrotect/Projects/BYMS_TFLITE_3_COMBINED/ASFskin_NoPartsv3_v8s.tflite"

PIG_CLASS_ID = 7
HUMAN_CLASS_ID = 0

PIG_CONF = 0.40
LESION_CONF = 0.70
REDNESS_CONF = 0.70

BEHAVIOR_INTERVAL = 12
ROI_PAD = 0.15

BEHAVIOR_NAMES = {0:"ACTIVE",1:"EATING",2:"GROUP",3:"INACTIVE"}
SKIN_NAMES = {1:"ASF LESION",2:"REDNESS"}

# ================= SORT-LIKE PIG TRACKING =================
pig_tracks = {}          # pig_id -> PigKalman
pig_last_seen = {}       # pig_id -> timestamp

# ---- ID MANAGEMENT (FIX ID INFLATION) ----
next_pig_id = 0
free_pig_ids = set()     # reusable IDs
MAX_PIG_IDS = 9         # realistic max pigs per pen

PIG_IOU_THRESHOLD = 0.4
PIG_TIMEOUT = 10  # seconds

# ===== ASF COUNTER =====
asf_hour_count = 0
current_hour_key = time.strftime("%Y-%m-%d %H-00")
last_asf_push = time.time() 

PIG_STATE_PATH = "/home/asfrotect/Desktop/pig_state.npy"

# ================= ALERT FLAGS =================
BEHAVIOR_ALERT = False
ABNORMAL_BEHAVIORS = {"INACTIVE"}  # add more if needed

# ================= FEVER LOGIC =================
FEVER_DELTA_C = 2.0          # >= 2ÃƒÂ¯Ã‚Â¿Ã‚Â½C rise indicates fever
thermal_hourly_avg = {}     # hour_key -> avgTemp

# ================= GSM =================
GSM_PORT = "/dev/ttyAMA0"
GSM_BAUD = 9600
SMS_NUMBERS = ["+639499884195", "+639209615316"]
SMS_TEMP_THRESHOLD = 40# ================= FEVER THRESHOLDS =================
ABSOLUTE_FEVER_C = SMS_TEMP_THRESHOLD  # reuse GSM threshold

gsm = None

# ================= HELPERS =================
def preprocess(img):
    img = cv2.resize(img, (INPUT_SIZE, INPUT_SIZE))
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    return (img.astype(np.float32) / 255.0)[None]

def compute_iou(a, b):
    xA, yA = max(a[0], b[0]), max(a[1], b[1])
    xB, yB = min(a[2], b[2]), min(a[3], b[3])
    inter = max(0, xB - xA) * max(0, yB - yA)
    areaA = max(0, a[2]-a[0]) * max(0, a[3]-a[1])
    areaB = max(0, b[2]-b[0]) * max(0, b[3]-b[1])
    return inter / (areaA + areaB - inter + 1e-6)

def nms_pig(dets, thr):
    dets = sorted(dets, key=lambda x: x[1], reverse=True)
    out = []
    while dets:
        best = dets.pop(0)
        out.append(best)
        dets = [d for d in dets if compute_iou(best[0], d[0]) < thr]
    return out

def nms_skin(dets, thr):
    dets = sorted(dets, key=lambda x: x[1], reverse=True)
    out = []
    while dets:
        best = dets.pop(0)
        out.append(best)
        dets = [d for d in dets if compute_iou(best[0], d[0]) < thr or best[2]!=d[2]]
    return out

def overlaps_any(box, boxes, thr=0.25):
    return any(compute_iou(box,b)>thr for b in boxes)

def pig_id(box):
    x1,y1,x2,y2 = box
    return (x1//30,y1//30,x2//30,y2//30)

def interval_seconds(mode,value):
    return value*60 if mode=="minute" else value*3600

def upload_to_cloudinary(image_path, date):
    try:
        result = cloudinary.uploader.upload(
            image_path,
            folder=f"asfrotect_detections/{date}",
            resource_type="image"
        )
        print("[CLOUDINARY UPLOADED]", result["secure_url"])
        return result["secure_url"]
    except Exception as e:
        print("[CLOUDINARY ERROR]", e)
        return None

def get_new_pig_id():
    global next_pig_id

    # reuse freed IDs first
    if free_pig_ids:
        return free_pig_ids.pop()

    # HARD LIMIT: do not exceed max pigs
    if next_pig_id >= MAX_PIG_IDS:
        return None   # <-- IMPORTANT

    pid = next_pig_id
    next_pig_id += 1
    return pid


def assign_pig_id(box):
    global next_pig_id

    best_id = None
    best_iou = 0.0

    for pid, tracker in pig_tracks.items():
        pred_box = tracker.predict()
        iou = compute_iou(box, pred_box)
        print(f"[SORT] Compare with pig {pid}, IOU={iou:.2f}")
        if iou > best_iou:
            best_iou = iou
            best_id = pid

    if best_iou >= PIG_IOU_THRESHOLD:
        print(f"[SORT] MATCH pig {best_id} (IOU={best_iou:.2f})")
        pig_tracks[best_id].update(box)
        pig_last_seen[best_id] = time.time()
        return best_id

    pid = get_new_pig_id()
    print(f"[SORT] NEW pig {pid}")
    pig_tracks[pid] = PigKalman(box)
    pig_last_seen[pid] = time.time()
    return pid

def get_asf_status(asf_count):
    if asf_count > 0:
        return f"ASF DETECTED ({asf_count})"
    else:
        return "NORMAL"

def push_asf_hourly_count():
    try:
        farm_id = "farm_001"
        hour_key = time.strftime("%Y-%m-%d %H-00")
        ref = db.reference(f"farms/{farm_id}/asf_hourly_counts")

        # Status based on number of ASF boxes
        status = get_asf_status(asf_hour_count)

        ref.child(hour_key).set({
            "asfCount": asf_hour_count,
            "status": status,
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
        })

    except Exception as e:
        print("[FIREBASE ASF ERROR]", e)

def push_hourly_behavior_counts():
    try:
        farm_id = "farm_001"
        hour_key = time.strftime("%Y-%m-%d %H-00")

        data = behavior_counts_hourly.get(hour_key, {})

        payload = {
            behavior: len(pigs)
            for behavior, pigs in data.items()
        }

        payload["timestamp"] = time.strftime("%Y-%m-%d %H:%M:%S")

        db.reference(
            f"farms/{farm_id}/behavior_hourly/{hour_key}"
        ).update(payload)

    except Exception as e:
        print("[FIREBASE BEHAVIOR HOURLY ERROR]", e)

def push_monitored_pigs():
    try:
        farm_id = "farm_001"
        date_key = time.strftime("%Y-%m-%d")

        count = len(monitored_pigs_daily.get(date_key, set()))

        db.reference(f"farms/{farm_id}/stats").update({
            "monitoredPigs": count,
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
        })

    except Exception as e:
        print("[FIREBASE MONITORED PIGS ERROR]", e)

def get_latest_cloudflare_url(log_path="/home/asfrotect/cloudflare.log"):
    import re, os

    if not os.path.exists(log_path):
        return None

    pattern = re.compile(r"https://[-\w]+\.trycloudflare\.com")
    last_match = None

    with open(log_path, "r") as f:
        lines = f.readlines()[-20:]  # read only recent lines

    for line in lines:
        match = pattern.search(line)
        if match:
            last_match = match.group(0)

    return last_match

import subprocess

def get_network_metrics(host="8.8.8.8", count=4, timeout=2):
    """
    Returns:
        packet_loss (float): % packet loss
        connection_drop (int): 1 if disconnected, else 0
    """
    try:
        output = subprocess.check_output(
            ["ping", "-c", str(count), "-W", str(timeout), host],
            stderr=subprocess.DEVNULL
        ).decode()

        match = re.search(r"(\d+)% packet loss", output)
        packet_loss = float(match.group(1)) if match else 100.0

        # connection drop if 100% loss
        connection_drop = 1 if packet_loss >= 100.0 else 0

        return packet_loss, connection_drop

    except Exception:
        # ping failed ? network down
        return 100.0, 1

def compute_upload_speed_mbps(file_path, upload_duration_sec):
    if upload_duration_sec <= 0:
        return 0.0

    file_size_bytes = os.path.getsize(file_path)
    return (file_size_bytes * 8) / upload_duration_sec / 1_000_000

class PigKalman:
    def __init__(self, bbox):
        self.kf = KalmanFilter(dim_x=8, dim_z=4)

        # state = cx, cy, w, h, dx, dy, dw, dh
        self.kf.F = np.eye(8)
        for i in range(4):
            self.kf.F[i, i+4] = 1

        self.kf.H = np.eye(4, 8)
        self.kf.R *= 10
        self.kf.P *= 1000
        self.kf.Q *= 0.01

        x1, y1, x2, y2 = bbox
        w, h = x2 - x1, y2 - y1
        cx, cy = x1 + w / 2, y1 + h / 2

        self.kf.x[:4] = [[cx], [cy], [w], [h]]

    def predict(self):
        self.kf.predict()
        cx, cy, w, h = self.kf.x[:4].flatten()
        return (
            int(cx - w / 2),
            int(cy - h / 2),
            int(cx + w / 2),
            int(cy + h / 2)
        )

    def update(self, bbox):
        x1, y1, x2, y2 = bbox
        w, h = x2 - x1, y2 - y1
        cx, cy = x1 + w / 2, y1 + h / 2
        self.kf.update([cx, cy, w, h])

# ================= INFERENCE =================
ASF_DETECTED = False
pig_behaviors = {}
# === LAST DETECTION CACHE (ADD THIS) ===
last_detect_frame = None
last_detection_time = None

def run_full_inference(frame,frame_id):
    global ASF_DETECTED, asf_hour_count, current_hour_key, BEHAVIOR_ALERT
    ASF_DETECTED = False
    BEHAVIOR_ALERT = False

    detect_frame = frame.copy()
    pigs, humans = [], []

    H,W,_ = frame.shape
    small = cv2.resize(frame,(SMALL_W,int(H*SMALL_W/W)))
    sx, sy = W/small.shape[1], H/small.shape[0]

    # ----- Pig detection -----
    pig_itp.set_tensor(pig_in[0]['index'], preprocess(small))
    pig_itp.invoke()
    preds = pig_itp.get_tensor(pig_out[0]['index'])[0].T
    for d in preds:
        x,y,bw,bh = d[:4]
        scores = d[4:]
        cid = int(np.argmax(scores))
        conf = float(scores[cid])
        if conf<PIG_CONF: continue

        x1=int((x-bw/2)*small.shape[1]*sx)
        y1=int((y-bh/2)*small.shape[0]*sy)
        x2=int((x+bw/2)*small.shape[1]*sx)
        y2=int((y+bh/2)*small.shape[0]*sy)

        if cid==PIG_CLASS_ID:
            pigs.append(((x1,y1,x2,y2),conf))
        elif cid==HUMAN_CLASS_ID:
            humans.append((x1,y1,x2,y2))
    pigs = nms_pig(pigs,0.4)

    # ----- Drawing + Skin -----
    for (x1,y1,x2,y2),conf in pigs:
        # Behavior label
        pid = assign_pig_id((x1, y1, x2, y2))
        # ---- MONITORED PIGS (UNIQUE DAILY COUNT) ----
        date_key = time.strftime("%Y-%m-%d")

        if date_key not in monitored_pigs_daily:
            monitored_pigs_daily[date_key] = set()

        monitored_pigs_daily[date_key].add(pid)
        label = ""
        if pid not in pig_behaviors or frame_id - pig_behaviors[pid][1]>=BEHAVIOR_INTERVAL:
            roi = frame[y1:y2,x1:x2]
            if roi.size !=0:
                beh_itp.set_tensor(beh_in[0]['index'], preprocess(roi))
                beh_itp.invoke()
                o = beh_itp.get_tensor(beh_out[0]['index'])[0].T
                behavior = BEHAVIOR_NAMES[int(np.argmax(max(o,key=lambda d:max(d[4:]))[4:]))]
                pig_behaviors[pid]=(behavior,frame_id)
                # ---- HOURLY BEHAVIOR COUNTING ----
                hour_key = time.strftime("%Y-%m-%d %H-00")

                if hour_key not in behavior_counts_hourly:
                    behavior_counts_hourly[hour_key] = {
                        name: set() for name in BEHAVIOR_NAMES.values()
                    }

                behavior_counts_hourly[hour_key][behavior].add(pid)

                if behavior in ABNORMAL_BEHAVIORS:
                    BEHAVIOR_ALERT = True
        label = pig_behaviors.get(pid, ("",))[0]

        if DRAW_PIG_BOXES:
            cv2.rectangle(detect_frame, (x1, y1), (x2, y2), (0,255,0), 2)
            cv2.putText(
                detect_frame,
                f"{conf:.2f} {label}",
                (x1, y1 - 6),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.45,
                (0, 255, 0),
                1
            )

        # Skin inference
        pw,ph=int((x2-x1)*ROI_PAD),int((y2-y1)*ROI_PAD)
        px1,py1=max(0,x1-pw),max(0,y1-ph)
        px2,py2=min(W,x2+pw),min(H,y2+ph)
        skin_roi = frame[py1:py2,px1:px2]
        if skin_roi.size==0: continue
        skin_itp.set_tensor(skin_in[0]['index'], preprocess(skin_roi))
        skin_itp.invoke()
        outs = skin_itp.get_tensor(skin_out[0]['index'])[0].T

        dets=[]
        for d in outs:
            x,y,bw,bh=d[:4]
            scores=d[4:]
            cid=int(np.argmax(scores))
            conf=float(scores[cid])
            if (cid==1 and conf<LESION_CONF) or (cid==2 and conf<REDNESS_CONF): continue
            if cid not in SKIN_NAMES: continue
            rx1=int(px1+(x-bw/2)*(px2-px1))
            ry1=int(py1+(y-bh/2)*(py2-py1))
            rx2=int(px1+(x+bw/2)*(px2-px1))
            ry2=int(py1+(y+bh/2)*(py2-py1))
            if overlaps_any((rx1,ry1,rx2,ry2),humans): continue
            dets.append(((rx1,ry1,rx2,ry2),conf,cid))

        for (bx1,by1,bx2,by2),conf,cid in nms_skin(dets,0.45):
            ASF_DETECTED = True
            hour_key = time.strftime("%Y-%m-%d %H-00")

            if hour_key not in asf_pigs_hourly:
                asf_pigs_hourly[hour_key] = set()

            if pid not in asf_pigs_hourly[hour_key]:
                asf_pigs_hourly[hour_key].add(pid)
                asf_hour_count = len(asf_pigs_hourly[hour_key])

            if DRAW_SKIN_BOXES:
                cv2.rectangle(detect_frame,(bx1,by1),(bx2,by2),(0,0,255),2)
                cv2.putText(detect_frame,f"{SKIN_NAMES[cid]} {conf:.2f}",
                            (bx1,by1-4),cv2.FONT_HERSHEY_SIMPLEX,0.4,(0,0,255),1)
    return detect_frame

# ================= GSM =================
def gsm_init():
    global gsm, gsm_initialized
    if gsm_initialized:
        return

    try:
        gsm = serial.Serial(GSM_PORT, GSM_BAUD, timeout=2)
        time.sleep(3)
        gsm_send("AT")
        gsm_send("ATE0")
        gsm_send("AT+CMGF=1")
        gsm_initialized = True
        print("[GSM] Initialized")
    except Exception as e:
        print("[GSM ERROR]", e)
        gsm = None

def gsm_send(cmd,wait=1):
    if gsm is None: return ""
    gsm.write((cmd+"\r").encode())
    time.sleep(wait)
    return gsm.read_all().decode(errors="ignore")

def send_sms(message):
    if gsm is None:
        print("[SMS] GSM not initialized")
        return

    for number in SMS_NUMBERS:
        print(f"[SMS] Sending to {number}...")

        resp = gsm_send(f'AT+CMGS="{number}"', 0.5)
        print("[GSM] CMGS response:", resp.strip())

        gsm.write(message.encode() + b"\x1A")
        time.sleep(3)

        final = gsm.read_all().decode(errors="ignore")
        print("[GSM] Final response:", final.strip())

        if "OK" in final or "+CMGS" in final:
            print("[SMS] Sent successfully")
        else:
            print("[SMS] Send may have failed")

def format_status_block(fever, lesion, behavior):
    return (
        "CURRENT STATUS SNAPSHOT:\n"
        f"- Fever: {'YES' if fever else 'NO'}\n"
        f"  Max temperature: {THERMAL_MAX_TEMP:.1f} °C\n"
        f"- ASF Lesion: {'YES' if lesion else 'NO'}\n"
        f"- Inactivity: {'YES' if behavior else 'NO'}\n\n"
        f"Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}"
    )


# ================= THERMAL =================
def draw_thermal_legend(img,tmin=20.0,tmax=40.0):
    h,w,_=img.shape; bar_w,pad_x=20,10; y1,y2=50,h-60; x1,x2=w-bar_w-pad_x,w-pad_x
    for i in range(y1,y2):
        ratio=1.0-(i-y1)/(y2-y1)
        temp=tmin+ratio*(tmax-tmin)
        norm=(temp-tmin)/(tmax-tmin)
        bgr=tuple(int(c*255) for c in reversed(cm.inferno(norm)[:3]))
        cv2.line(img,(x1,i),(x2,i),bgr,1)
    cv2.rectangle(img,(x1,y1),(x2,y2),(255,255,255),1)
    for temp,y in [(tmax,y1+14),(tmin,y2-6)]:
        label=f"{int(temp)} C"
        (tw,_),_=cv2.getTextSize(label,cv2.FONT_HERSHEY_SIMPLEX,0.45,1)
        cv2.putText(img,label,(x1-tw-8,y),cv2.FONT_HERSHEY_SIMPLEX,0.45,(255,255,255),1)

def draw_metadata_bar(img):
    h,w,_=img.shape
    timestamp=time.strftime("%Y-%m-%d %H:%M:%S")
    text=f"{timestamp} | Tmin: {THERMAL_MIN_TEMP:.1f} C | Tavg: {THERMAL_AVG_TEMP:.1f} C | Tmax: {THERMAL_MAX_TEMP:.1f} C"
    bar_h=30
    cv2.rectangle(img,(0,h-bar_h),(w,h),(0,0,0),-1)
    cv2.putText(img,text,(10,h-8),cv2.FONT_HERSHEY_SIMPLEX,0.55,(255,255,255),2,cv2.LINE_AA)

def save_pig_state():
    data = {
        "next_pig_id": next_pig_id,
        "tracks": {
            pid: tracker.kf.x.tolist()
            for pid, tracker in pig_tracks.items()
        }
    }
    np.save(PIG_STATE_PATH, data)

# ================= LOAD MODELS =================
def load_model(path):
    itp=Interpreter(model_path=path,num_threads=4)
    itp.allocate_tensors()
    return itp

def load_all_models():
    pig=load_model(PIG_MODEL)
    beh=load_model(BEHAVIOR_MODEL)
    skin=load_model(SKIN_MODEL)
    return (pig,beh,skin,
            pig.get_input_details(),pig.get_output_details(),
            beh.get_input_details(),beh.get_output_details(),
            skin.get_input_details(),skin.get_output_details())

def letterbox(img, target_w=STREAM_W, target_h=STREAM_H):
    h, w = img.shape[:2]
    scale = min(target_w/w, target_h/h)
    nw, nh = int(w*scale), int(h*scale)
    resized = cv2.resize(img, (nw, nh))

    canvas = np.zeros((target_h, target_w, 3), dtype=np.uint8)
    x = (target_w - nw) // 2
    y = (target_h - nh) // 2
    canvas[y:y+nh, x:x+nw] = resized
    return canvas

# ================= CAMERA =================
picam2=Picamera2()
picam2.configure(
    picam2.create_preview_configuration(
        main={"format": "RGB888", "size": (CAM_W, CAM_H)},
        controls={
            "FrameRate": 5,
            "NoiseReductionMode": 2,   # HIGH QUALITY
            "Sharpness": 1.2,
            "Contrast": 1.1,
            "Saturation": 1.05
        }
    )
)
picam2.start()

pig_itp, beh_itp, skin_itp, \
pig_in, pig_out, \
beh_in, beh_out, \
skin_in, skin_out = load_all_models()

# ================= RESTORE PIG TRACK STATE =================
PIG_STATE_PATH = "/home/asfrotect/Desktop/pig_state.npy"

if os.path.exists(PIG_STATE_PATH):
    try:
        data = np.load(PIG_STATE_PATH, allow_pickle=True).item()
        next_pig_id = data.get("next_pig_id", 0)

        for pid, state in data.get("tracks", {}).items():
            pk = PigKalman((0, 0, 1, 1))  # dummy bbox
            pk.kf.x = np.array(state)
            pig_tracks[int(pid)] = pk
            pig_last_seen[int(pid)] = time.time()

        print(f"[SORT] Restored {len(pig_tracks)} pig tracks")

    except Exception as e:
        print("[SORT] Failed to restore pig state:", e)

# ================= THERMAL INIT =================
if THERMAL_AVAILABLE:
    i2c=busio.I2C(board.SCL,board.SDA)
    mlx90640=adafruit_mlx90640.MLX90640(i2c)
    mlx90640.refresh_rate=adafruit_mlx90640.RefreshRate.REFRESH_4_HZ
    thermal_frame=np.zeros((24*32,),dtype=float)

last_thermal_time=0
cached_thermal_resized=None
thermal_lock=threading.Lock()

def read_thermal():
    global THERMAL_MIN_TEMP, THERMAL_MAX_TEMP, THERMAL_AVG_TEMP
    try:
        mlx90640.getFrame(thermal_frame)
        data = thermal_frame.reshape((24, 32))

        # ---- HARD FILTER (CRITICAL) ----
        valid = data[
            (data > 15.0) &    # below this is noise
            (data < 42.0)      # pigs should NEVER exceed this
        ]

        # if frame is corrupted, ignore it
        if valid.size < 100:
            return None

        # ---- ROBUST STATISTICS ----
        THERMAL_MIN_TEMP = float(np.percentile(valid, 5))
        THERMAL_MAX_TEMP = float(np.percentile(valid, 95))
        THERMAL_AVG_TEMP = float(np.mean(valid))

        return data

    except (RuntimeError, OSError) as e:
        print(f"[THERMAL WARNING] {e}")
        return None


def thermal_to_rgb(t):
    global thermal_ema

    # ---------- 1. Temporal smoothing (EMA) ----------
    if thermal_ema is None:
        thermal_ema = t.astype(np.float32)
    else:
        thermal_ema = (
            THERMAL_ALPHA * t +
            (1.0 - THERMAL_ALPHA) * thermal_ema
        )

    t = thermal_ema

    # ---------- 2. Spatial smoothing (remove grid) ----------
    # Gaussian is better than blur after colormap
    #t = cv2.GaussianBlur(t, (3, 3), 0)

    # ---------- 3. Stable temperature range ----------
    tmin = max(20.0, THERMAL_MIN_TEMP)
    tmax = min(42.0, THERMAL_MAX_TEMP)

    # Prevent division issues
    if tmax - tmin < 0.5:
        tmax = tmin + 0.5

    # ---------- 4. Normalize safely ----------
    norm = np.clip(
        (t - tmin) / (tmax - tmin),
        0.0,
        1.0
    )

    # ---------- 5. Colormap ----------
    rgb = (cm.inferno(norm)[:, :, :3] * 255).astype(np.uint8)

    return rgb

def is_mobile():
    ua = request.headers.get("User-Agent", "").lower()
    mobile_keywords = [
        "iphone", "ipad", "android", "mobile",
        "opera mini", "opera mobi",
        "blackberry", "windows phone"
    ]
    return any(k in ua for k in mobile_keywords)

# ================= STREAM =================
app=Flask(__name__)
latest_frame=None
frame_lock=threading.Lock()

@app.route("/")
def index():
    print("[FLASK] / hit")  # <-- ADD THIS
    return "FLASK IS WORKING"


def generate_stream(is_mobile_client=False):
    global latest_frame
    print("[STREAM] Client connected | mobile =", is_mobile_client)

    quality = 50 if is_mobile_client else 65
    delay = 0.15 if is_mobile_client else 0.08

    while True:
        with frame_lock:
            frame = latest_frame

        if frame is None:
            time.sleep(0.1)
            continue

        ret, jpeg = cv2.imencode(
            ".jpg",
            frame,
            [cv2.IMWRITE_JPEG_QUALITY, quality]
        )

        if not ret:
            continue

        yield (
            b"--frame\r\n"
            b"Content-Type: image/jpeg\r\n\r\n" +
            jpeg.tobytes() + b"\r\n"
        )

        time.sleep(delay)

@app.route("/video")
def video():
    mobile = is_mobile()

    return Response(
        generate_stream(is_mobile_client=mobile),
        mimetype="multipart/x-mixed-replace; boundary=frame",
        headers={
            "Cache-Control": "no-cache, no-store, must-revalidate",
            "Pragma": "no-cache",
            "Expires": "0",
            "X-Accel-Buffering": "no"
        }
    )

@app.route("/stream")
def stream_auto():
    mobile = is_mobile()  # SAFE here

    if mobile:
        return (
            "<html><body style='margin:0;background:black;'>"
            "<img src='/video' style='width:100%;height:auto;'/>"
            "</body></html>"
        )

    return Response(
        generate_stream(is_mobile_client=mobile),
        mimetype="multipart/x-mixed-replace; boundary=frame",
        headers={
            "Cache-Control": "no-cache",
            "Pragma": "no-cache",
            "X-Accel-Buffering": "no"
        }
    )

threading.Thread(
    target=lambda: app.run(host="0.0.0.0", port=8080, threaded=True),
    daemon=True
).start()

time.sleep(2)  # allow Flask to start

# ================= CLOUDFLARE WATCHER =================
def cloudflare_watcher():
    last_url = None
    farm_id = "farm_001"

    while True:
        try:
            base = get_latest_cloudflare_url()
            if base:
                stream_url = f"{base}/stream"

                if stream_url != last_url:
                    db.reference("SwineWatchData/live_url").set(stream_url)
                    print("[CLOUDFLARE] Updated live URL:", stream_url)
                    last_url = stream_url

        except Exception as e:
            print("[CLOUDFLARE WATCH ERROR]", e)

        time.sleep(5)

# start watcher in background
threading.Thread(target=cloudflare_watcher, daemon=True).start()

def get_cloudflare_url(log_path="/home/asfrotect/cloudflare.log", timeout=30):
    import time, re, os

    pattern = re.compile(r"https://[-\w]+\.trycloudflare\.com")
    start = time.time()

    while time.time() - start < timeout:
        if os.path.exists(log_path):
            with open(log_path, "r") as f:
                for line in f:
                    match = pattern.search(line)
                    if match:
                        return match.group(0)
        time.sleep(1)

    raise RuntimeError("Cloudflare URL not found in log")

def push_live_thermal_to_firebase():
    try:
        farm_id = "farm_001"
        ref = db.reference(f"farms/{farm_id}/live_thermal")

        ref.set({            
            "avgTemp": round(THERMAL_MAX_TEMP, 1),
            "fever": THERMAL_MAX_TEMP >= ABSOLUTE_FEVER_C,
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
        })

    except Exception as e:
        print("[FIREBASE THERMAL ERROR]", e)

def thermal_loop():
    global cached_thermal_resized
    last_firebase_push = 0

    while True:
        if THERMAL_AVAILABLE:
            try:
                tdata = read_thermal()
            except (RuntimeError, OSError) as e:
                print("[THERMAL I2C ERROR]", e)
                reset_thermal()
                time.sleep(2)
                continue

            if tdata is not None:
                global thermal_fps, last_thermal_frame_ts

                now_ts = time.time()
                if last_thermal_frame_ts is not None:
                    thermal_fps = 1.0 / max(1e-6, now_ts - last_thermal_frame_ts)
                last_thermal_frame_ts = now_ts

                rgb = thermal_to_rgb(tdata)
                rgb = cv2.resize(
                    rgb,
                    (THERMAL_W, THERMAL_H),
                    interpolation=cv2.INTER_CUBIC
                )
                rgb = cv2.GaussianBlur(rgb, (3, 3), 0)
                draw_thermal_legend(rgb)

                with thermal_lock:
                    cached_thermal_resized = rgb

                # ---- PUSH TO FIREBASE EVERY 5 SECONDS ----
                if time.time() - last_firebase_push > 5:
                    push_live_thermal_to_firebase()
                    last_firebase_push = time.time()

        time.sleep(1)

def reset_thermal():
    global mlx90640, i2c
    try:
        print("[THERMAL] Resetting sensor...")
        time.sleep(1)
        i2c = busio.I2C(board.SCL, board.SDA)
        mlx90640 = adafruit_mlx90640.MLX90640(i2c)
        mlx90640.refresh_rate = adafruit_mlx90640.RefreshRate.REFRESH_4_HZ
        print("[THERMAL] Sensor recovered")
    except Exception as e:
        print("[THERMAL] Reset failed:", e)

threading.Thread(target=thermal_loop,daemon=True).start()

# ================= MAIN LOOP ================
INTERVAL_SEC = interval_seconds(INTERVAL_MODE, INTERVAL_VALUE)
next_detection_time = time.time() + INTERVAL_SEC
frame_id = 0
last_date_key = time.strftime("%Y-%m-%d")
fps_t = time.time()
os.makedirs(SAVE_ROOT, exist_ok=True)

while True:
    # ---- DAILY RESET FOR MONITORED PIGS ----
    current_date = time.strftime("%Y-%m-%d")
    if current_date != last_date_key:
        monitored_pigs_daily.clear()
        last_date_key = current_date
        print("[RESET] Monitored pigs reset for new day")

    # Capture frame for preview only
    frame = picam2.capture_array()
    if frame.shape[1] != CAM_W or frame.shape[0] != CAM_H:
        print("[WARN] Camera resolution drifted:", frame.shape)
        frame = cv2.resize(frame, (CAM_W, CAM_H))
    frame_id += 1

    # Thermal overlay
    with thermal_lock:
        thermal_img = cached_thermal_resized

    # FAST live preview (NO inference)
    preview = frame.copy()

    # ipakita ang huling detection kung meron
    if last_detect_frame is not None and time.time() - last_detection_time < 5:
        preview = last_detect_frame.copy()
        cv2.putText(
            preview,
            "LAST DETECTION",
            (10, 30),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.7,
            (0, 0, 255),
            2
        )

    # thermal side-by-side
    if thermal_img is not None and preview.shape[:2] == thermal_img.shape[:2]:
        preview = cv2.hconcat([preview, thermal_img])
    # Draw metadata
    draw_metadata_bar(preview)

    # Update streaming frame
    with frame_lock:
        if thermal_img is None:
            preview = letterbox(preview)   # crop ONLY camera-only view
        preview = cv2.resize(preview, (STREAM_W, STREAM_H))
        latest_frame = preview.copy()

    # Show window if enabled
    if SHOW_OPENCV_WINDOW:
        cv2.imshow("Preview", preview)
        if cv2.waitKey(1) & 0xFF == ord("q"):
            break

        # ================= INTERVAL DETECTION =================
    now = time.time()
    if now >= next_detection_time:

        capture_ts = next_detection_time  # scheduled trigger time
        # ---- CAPTURE METADATA ----
        pi_h, pi_w = frame.shape[:2]
        pi_fps_at_capture = PI_CAM_FPS

        thermal_res = (32, 24)   # raw MLX90640 resolution
        thermal_fps_at_capture = thermal_fps

        # --- hourly ASF push ---
        if time.time() - last_asf_push > 60 * 60:  # 1 hour
            push_asf_hourly_count()
            last_asf_push = time.time()

        # ================= INFERENCE =================
        infer_start_ts = time.time()

        detect_frame = run_full_inference(frame, frame_id)

        infer_end_ts = time.time()
        # ================= NETWORK METRICS =================
        packet_loss, connection_drop = get_network_metrics()

        # ================= HOUSEKEEPING =================
        push_hourly_behavior_counts()
        push_monitored_pigs()
        save_pig_state()

        now = time.time()
        for pid in list(pig_last_seen.keys()):
            if now - pig_last_seen[pid] > PIG_TIMEOUT:
                pig_tracks.pop(pid, None)
                pig_last_seen.pop(pid, None)
                free_pig_ids.add(pid)   # <-- IMPORTANT
        if not pig_tracks:
            free_pig_ids.clear()
            next_pig_id = 0

        # ---- RECORD HOURLY THERMAL AVERAGE ----
        hour_key = time.strftime("%Y-%m-%d %H-00")
        thermal_hourly_samples.setdefault(hour_key, []).append(THERMAL_MAX_TEMP)
        thermal_hourly_avg[hour_key] = float(
            np.mean(thermal_hourly_samples[hour_key])
        )

        for d in [thermal_hourly_avg, thermal_hourly_samples]:
            if len(d) > 24:
                for k in sorted(d.keys())[:-24]:
                    d.pop(k)

        # ---- FEVER DETECTION (UNIFIED) ----
        hour_key = time.strftime("%Y-%m-%d %H-00")

        fever_delta = False
        fever_absolute = THERMAL_MAX_TEMP >= ABSOLUTE_FEVER_C

        prev_hours = sorted(thermal_hourly_avg.keys())
        if len(prev_hours) >= 2:
            prev_key = prev_hours[-2]
            delta = thermal_hourly_avg[hour_key] - thermal_hourly_avg[prev_key]
            if delta >= FEVER_DELTA_C:
                fever_delta = True

        fever_detected = fever_absolute or fever_delta
        fever_hourly[hour_key] = fever_detected

        lesion_hourly[hour_key] = ASF_DETECTED

        # ---- KEEP LAST 24 HOURS OF BEHAVIOR COUNTS ----
        if len(behavior_counts_hourly) > 24:
            for k in sorted(behavior_counts_hourly.keys())[:-24]:
                behavior_counts_hourly.pop(k)

        # ---- KEEP LAST 24 HOURS OF BOOLEAN HISTORIES ----
        for history in [fever_hourly, lesion_hourly]:
            if len(history) > 24:
                for k in sorted(history.keys())[:-24]:
                    history.pop(k)

        # emergency cleanup
        if len(pig_tracks) > 100:
            pig_tracks.clear()
            pig_last_seen.clear()
            next_pig_id = 0

        last_detect_frame = detect_frame.copy()
        last_detection_time = time.time()
        # ---- advance schedule safely (no drift) ----
        while next_detection_time <= time.time():
            next_detection_time += INTERVAL_SEC

        # Combine with thermal for saving
        with thermal_lock:
            thermal_img = cached_thermal_resized

        if thermal_img is not None and detect_frame.shape[:2] == thermal_img.shape[:2]:
            combined = cv2.hconcat([detect_frame, thermal_img])
        else:
            combined = detect_frame

        draw_metadata_bar(combined)

        # Save locally
        date = time.strftime("%Y-%m-%d")
        tstamp = time.strftime("%H-%M-%S")
        save_dir = os.path.join(SAVE_ROOT, date)
        os.makedirs(save_dir, exist_ok=True)
        save_path = os.path.join(save_dir, f"{tstamp}.jpg")
        cv2.imwrite(save_path, combined)
        print(f"[SAVED] {save_path}")

        cloud_upload_start = time.time()
        cloud_url = upload_to_cloudinary(save_path, date)
        cloud_upload_end = time.time()
        cloud_upload_ts = cloud_upload_end

        upload_duration = cloud_upload_end - cloud_upload_start
        upload_speed_mbps = compute_upload_speed_mbps(
            save_path,
            upload_duration
        )

        # ================= NETWORK + UPLOAD LOG (NEW FILE) =================
        NETWORK_LOG_PATH = "/home/asfrotect/Desktop/network_upload_log.csv"

        try:
            file_exists = os.path.exists(NETWORK_LOG_PATH)

            with open(NETWORK_LOG_PATH, "a", newline="") as f:
                import csv
                from datetime import datetime

                writer = csv.writer(f)

                if not file_exists:
                    writer.writerow([
                        "upload_time",
                        "packet_loss_percent",
                        "connection_drop",
                        "upload_speed_mbps",
                        "inference_latency_sec",
                        "total_latency_sec"
                    ])

                inference_latency = infer_end_ts - infer_start_ts
                total_latency = infer_end_ts - capture_ts

                writer.writerow([
                    datetime.fromtimestamp(cloud_upload_start).isoformat(),
                    packet_loss,
                    connection_drop,
                    round(upload_speed_mbps, 3),
                    round(inference_latency, 4),
                    round(total_latency, 4)
                ])

        except Exception as e:
            print("[NETWORK LOG ERROR]", e)


        # ---------------- LATENCY LOGGING ----------------
        LATENCY_LOG_PATH = "/home/asfrotect/Desktop/latency_log.csv"

        try:
            file_exists = os.path.exists(LATENCY_LOG_PATH)

            with open(LATENCY_LOG_PATH, "a", newline="") as f:
                import csv
                from datetime import datetime

                writer = csv.writer(f)

                # write header only if file was just created
                if not file_exists:
                    writer.writerow([
                        "capture_time",
                        "inference_start_time",
                        "cloudinary_upload_time",

                        "job_delay_sec",
                        "inference_latency_sec",
                        "total_latency_sec",

                        "pi_fps",
                        "pi_resolution",

                        "thermal_fps",
                        "thermal_resolution",

                        "image_path"
                    ])


                job_delay = infer_start_ts - capture_ts
                real_latency = infer_end_ts - infer_start_ts
                total_time = infer_end_ts - capture_ts

                writer.writerow([
                    datetime.fromtimestamp(capture_ts).isoformat(),
                    datetime.fromtimestamp(infer_start_ts).isoformat(),
                    datetime.fromtimestamp(cloud_upload_ts).isoformat(),

                    round(job_delay, 4),
                    round(real_latency, 4),
                    round(total_time, 4),

                    round(pi_fps_at_capture, 2),
                    f"{pi_w}x{pi_h}",

                    round(thermal_fps_at_capture, 2),
                    f"{thermal_res[0]}x{thermal_res[1]}",

                    save_path
                ])

        except Exception as e:
            print("[LATENCY LOG ERROR]", e)


        # Save to Firebase
        if cloud_url:
            hour_key = time.strftime("%Y-%m-%d %H-00")
            farm_id = "farm_001"
            ref = db.reference(f"farms/{farm_id}/detections/{date}/{hour_key}")
            ref.push({
                "imageUrl": cloud_url,
                "avgTemp": round(THERMAL_AVG_TEMP, 1),
                "minTemp": round(THERMAL_MIN_TEMP, 1),
                "maxTemp": round(THERMAL_MAX_TEMP, 1),
                "asfDetected": ASF_DETECTED,
                "fever": fever_detected,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
            })

        # ================= ALERT DECISION LOGIC =================
        status_block = format_status_block(
            fever_detected,
            ASF_DETECTED,
            BEHAVIOR_ALERT
        )
        
        gsm_init()
        
        alert_triggered = (
            BEHAVIOR_ALERT or
            fever_detected or
            ASF_DETECTED
        )
        
        if alert_triggered:
            send_sms(
                "⚠️ ASF ALERT ⚠️\n\n" +
                format_status_block(
                    fever_detected,
                    ASF_DETECTED,
                    BEHAVIOR_ALERT
                )
            )


    # FPS display
    now = time.time()
    PI_CAM_FPS = 1.0 / max(1e-6, now - fps_t)
    fps_t = now
    print(f"\rPi FPS: {PI_CAM_FPS:.1f}", end="")
