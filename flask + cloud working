just fix this whole code instead i am confused as to what to changed and after doing so send me the whole code

import cv2
import numpy as np
import time
import os
import cloudinary
import cloudinary.uploader
from tflite_runtime.interpreter import Interpreter
from picamera2 import Picamera2
import serial
import firebase_admin
from firebase_admin import credentials, db
from flask import Flask, Response
import threading


cred = credentials.Certificate(
    "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/firebase.json"
)

if not firebase_admin._apps:
    firebase_admin.initialize_app(cred, {
        "databaseURL": "https://asfrotect-default-rtdb.asia-southeast1.firebasedatabase.app/"
    })
#=======cloudtowalanya======
cloudinary.config(
    cloud_name="dmjhw3xa2",
    api_key="518441677687474",
    api_secret="uWQqwVKVN7QZ_AcU5dWy4htZvR0",
    secure=True
)

# ================= THERMAL =================
try:
    import board
    import busio
    import adafruit_mlx90640
    from matplotlib import cm
    THERMAL_AVAILABLE = True
except Exception as e:
    print("Thermal not available:", e)
    THERMAL_AVAILABLE = False

# ================= PERFORMANCE =================
cv2.setNumThreads(0)
cv2.ocl.setUseOpenCL(False)

# ================= CONFIG =================
INPUT_SIZE = 416
SMALL_W = 320

INTERVAL_MODE = "minute"
INTERVAL_VALUE = 1.5
SAVE_ROOT = "/home/asfrotect/Desktop/detections"

PI_CAM_FPS = 0.0
THERMAL_MIN_TEMP = 0.0
THERMAL_MAX_TEMP = 0.0
THERMAL_AVG_TEMP = 0.0

# ================= LIVE INFERENCE SWITCHES =================
LIVE_PIG_INFERENCE = True
LIVE_BEHAVIOR_INFERENCE = False
LIVE_SKIN_INFERENCE = True

SHOW_OPENCV_WINDOW = False

# ================= MODELS =================
PIG_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/PigvsNONPig-v2_float16.tflite"
BEHAVIOR_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/bestv8_behavior-2_float16.tflite"
SKIN_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/ASFskin_NoPartsv3_v8s.tflite"

PIG_CLASS_ID = 7
HUMAN_CLASS_ID = 0

PIG_CONF = 0.50
LESION_CONF = 0.10
REDNESS_CONF = 0.10

BEHAVIOR_INTERVAL = 12
ROI_PAD = 0.15

BEHAVIOR_NAMES = {
    0: "ACTIVE",
    1: "EATING",
    2: "GROUP",
    3: "INACTIVE"
}

SKIN_NAMES = {
    1: "ASF LESION",
    2: "REDNESS"
}

# ================= GSM / SMS CONFIG =================
GSM_PORT = "/dev/ttyAMA0"
GSM_BAUD = 9600
SMS_NUMBER = "+639369485057"

SMS_TEMP_THRESHOLD = 40.0

gsm = None
cached_thermal_resized = None
thermal_lock = threading.Lock()

# ================= HELPERS =================
def preprocess(img):
    img = cv2.resize(img, (INPUT_SIZE, INPUT_SIZE))
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    return (img.astype(np.float32) / 255.0)[None]

def compute_iou(a, b):
    xA, yA = max(a[0], b[0]), max(a[1], b[1])
    xB, yB = min(a[2], b[2]), min(a[3], b[3])
    inter = max(0, xB - xA) * max(0, yB - yA)
    areaA = max(0, a[2]-a[0]) * max(0, a[3]-a[1])
    areaB = max(0, b[2]-b[0]) * max(0, b[3]-b[1])
    return inter / (areaA + areaB - inter + 1e-6)

def nms_pig(dets, thr):
    dets = sorted(dets, key=lambda x: x[1], reverse=True)
    out = []
    while dets:
        best = dets.pop(0)
        out.append(best)
        dets = [d for d in dets if compute_iou(best[0], d[0]) < thr]
    return out

def nms_skin(dets, thr):
    dets = sorted(dets, key=lambda x: x[1], reverse=True)
    out = []
    while dets:
        best = dets.pop(0)
        out.append(best)
        dets = [d for d in dets if compute_iou(best[0], d[0]) < thr or best[2] != d[2]]
    return out

def overlaps_any(box, boxes, thr=0.25):
    return any(compute_iou(box, b) > thr for b in boxes)

def pig_id(box):
    x1, y1, x2, y2 = box
    return (x1//30, y1//30, x2//30, y2//30)

def interval_seconds(mode, value):
    return value * 60 if mode == "minute" else value * 3600

def print_countdown(last_time, interval_sec):
    remaining = int(interval_sec - (time.time() - last_time))
    remaining = max(0, remaining)
    m, s = divmod(remaining, 60)
    print(f"\rNext capture in: {m:02d}:{s:02d}", end="")
    # ================= CLOUDINARY UPLOAD =================
def upload_to_cloudinary(image_path, date):
    try:
        result = cloudinary.uploader.upload(
            image_path,
            folder=f"asfrotect_detections/{date}",
            resource_type="image"
        )
        print("[CLOUDINARY UPLOADED]", result["secure_url"])
        return result["secure_url"]
    except Exception as e:
        print("[CLOUDINARY ERROR]", e)
        return None

def run_full_inference(frame):
    global ASF_DETECTED

    ASF_DETECTED = False
    detect_frame = frame.copy()
    pigs = []
    humans = []

    H, W, _ = frame.shape

    # ---------- PIG INFERENCE ----------
    small = cv2.resize(frame, (SMALL_W, int(H * SMALL_W / W)))
    sx, sy = W / small.shape[1], H / small.shape[0]

    pig_itp.set_tensor(pig_in[0]['index'], preprocess(small))
    pig_itp.invoke()
    preds = pig_itp.get_tensor(pig_out[0]['index'])[0].T

    for d in preds:
        x,y,bw,bh = d[:4]
        scores = d[4:]
        cid = int(np.argmax(scores))
        conf = float(scores[cid])
        if conf < PIG_CONF:
            continue

        x1 = int((x-bw/2)*small.shape[1]*sx)
        y1 = int((y-bh/2)*small.shape[0]*sy)
        x2 = int((x+bw/2)*small.shape[1]*sx)
        y2 = int((y+bh/2)*small.shape[0]*sy)

        if cid == PIG_CLASS_ID:
            pigs.append(((x1,y1,x2,y2), conf))
        elif cid == HUMAN_CLASS_ID:
            humans.append((x1,y1,x2,y2))

    pigs = nms_pig(pigs, 0.4)

    # ---------- DRAW + SKIN ----------
    for (x1,y1,x2,y2), conf in pigs:
        cv2.rectangle(detect_frame,(x1,y1),(x2,y2),(0,255,0),2)
        cv2.putText(detect_frame,f"PIG {conf:.2f}",
                    (x1,y1-6),cv2.FONT_HERSHEY_SIMPLEX,0.45,(0,255,0),1)

        pw, ph = int((x2-x1)*ROI_PAD), int((y2-y1)*ROI_PAD)
        px1, py1 = max(0,x1-pw), max(0,y1-ph)
        px2, py2 = min(W,x2+pw), min(H,y2+ph)

        skin_roi = frame[py1:py2, px1:px2]
        if skin_roi.size == 0:
            continue

        skin_itp.set_tensor(skin_in[0]['index'], preprocess(skin_roi))
        skin_itp.invoke()
        outs = skin_itp.get_tensor(skin_out[0]['index'])[0].T

        for d in outs:
            x,y,bw,bh = d[:4]
            scores = d[4:]
            cid = int(np.argmax(scores))
            conf = float(scores[cid])

            if cid not in SKIN_NAMES:
                continue
            if conf < 0.1:
                continue

            rx1 = int(px1+(x-bw/2)*(px2-px1))
            ry1 = int(py1+(y-bh/2)*(py2-py1))
            rx2 = int(px1+(x+bw/2)*(px2-px1))
            ry2 = int(py1+(y+bh/2)*(py2-py1))

            if overlaps_any((rx1,ry1,rx2,ry2), humans):
                continue

            ASF_DETECTED = True
            cv2.rectangle(detect_frame,(rx1,ry1),(rx2,ry2),(0,0,255),2)
            cv2.putText(detect_frame,SKIN_NAMES[cid],
                        (rx1,ry1-4),cv2.FONT_HERSHEY_SIMPLEX,0.4,(0,0,255),1)

    return detect_frame

# ================= GSM HELPERS =================
def gsm_init():
    global gsm
    try:
        gsm = serial.Serial(GSM_PORT, GSM_BAUD, timeout=2)
        time.sleep(3)
        gsm_send("AT")
        gsm_send("ATE0")
        gsm_send("AT+CMGF=1")   # SMS text mode
        gsm_send("AT+CSQ")
        gsm_send("AT+CREG?")
        print("[GSM] Initialized")
    except Exception as e:
        print("[GSM ERROR]", e)
        gsm = None

def gsm_send(cmd, wait=1):
    if gsm is None:
        return ""
    gsm.write((cmd + "\r").encode())
    time.sleep(wait)
    return gsm.read_all().decode(errors="ignore")

def send_sms(message):
    if gsm is None:
        print("[SMS] GSM not initialized")
        return

    print("[SMS] Sending message...")
    gsm_send(f'AT+CMGS="{SMS_NUMBER}"', 0.5)
    gsm.write(message.encode() + b"\x1A")
    time.sleep(3)

    resp = gsm.read_all().decode(errors="ignore")

    if "+CMGS:" in resp:
        print("[SMS] SENT SUCCESSFULLY")
    elif "ERROR" in resp:
        print("[SMS] FAILED:", resp.strip())
    else:
        print("[SMS] MODEM RESPONSE:", resp.strip())

# ================= THERMAL LEGEND =================
def draw_thermal_legend(img, tmin=20.0, tmax=40.0):
    h, w, _ = img.shape
    bar_w, pad_x = 20, 10
    y1, y2 = 50, h - 60
    x1, x2 = w - bar_w - pad_x, w - pad_x

    for i in range(y1, y2):
        ratio = 1.0 - (i - y1) / (y2 - y1)
        temp = tmin + ratio * (tmax - tmin)
        norm = (temp - tmin) / (tmax - tmin)
        bgr = tuple(int(c * 255) for c in reversed(cm.inferno(norm)[:3]))
        cv2.line(img, (x1, i), (x2, i), bgr, 1)

    cv2.rectangle(img, (x1, y1), (x2, y2), (255,255,255), 1)

    for temp, y in [(tmax, y1+14), (tmin, y2-6)]:
        label = f"{int(temp)} C"
        (tw, _), _ = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.45, 1)
        cv2.putText(img, label, (x1 - tw - 8, y),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.45, (255,255,255), 1)

def draw_metadata_bar(img):
    h, w, _ = img.shape

    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")

    text = (
        f"{timestamp} | "
        f"Tmin: {THERMAL_MIN_TEMP:.1f} C | "
        f"Tavg: {THERMAL_AVG_TEMP:.1f} C | "
        f"Tmax: {THERMAL_MAX_TEMP:.1f} C"
    )

    # Background bar
    bar_h = 30
    cv2.rectangle(img, (0, h - bar_h), (w, h), (0, 0, 0), -1)

    # Text
    cv2.putText(
        img,
        text,
        (10, h - 8),
        cv2.FONT_HERSHEY_SIMPLEX,
        0.55,
        (255, 255, 255),
        2,
        cv2.LINE_AA
    )

# ================= LOAD MODELS =================
def load_model(path):
    itp = Interpreter(model_path=path, num_threads=4)
    itp.allocate_tensors()
    return itp

def load_all_models():
    pig = load_model(PIG_MODEL)
    beh = load_model(BEHAVIOR_MODEL)
    skin = load_model(SKIN_MODEL)

    return (
        pig, beh, skin,
        pig.get_input_details(), pig.get_output_details(),
        beh.get_input_details(), beh.get_output_details(),
        skin.get_input_details(), skin.get_output_details()
    )

# ================= CAMERA =================
picam2 = Picamera2()
picam2.configure(
    picam2.create_preview_configuration(
        main={"format": "RGB888", "size": (640, 480)},
        controls={"FrameRate": 5}   # ? LIMIT FPS
    )
)
picam2.start()

pig_itp, beh_itp, skin_itp, \
pig_in, pig_out, \
beh_in, beh_out, \
skin_in, skin_out = load_all_models()
# ================= THERMAL INIT =================
if THERMAL_AVAILABLE:
    i2c = busio.I2C(board.SCL, board.SDA)
    mlx90640 = adafruit_mlx90640.MLX90640(i2c)
    mlx90640.refresh_rate = adafruit_mlx90640.RefreshRate.REFRESH_4_HZ
    thermal_frame = np.zeros((24 * 32,), dtype=float)

last_thermal_time = 0
cached_thermal_rgb = None

def read_thermal():
    global THERMAL_AVG_TEMP, THERMAL_MIN_TEMP, THERMAL_MAX_TEMP
    try:
        mlx90640.getFrame(thermal_frame)
        data = thermal_frame.reshape((24, 32))

        THERMAL_MIN_TEMP = float(np.min(data))
        THERMAL_MAX_TEMP = float(np.max(data))
        THERMAL_AVG_TEMP = float(np.mean(data))

        return data
    except RuntimeError as e:
        print(f"[THERMAL WARNING] {e}")
        return None

def thermal_to_rgb(t):
    return (cm.inferno(np.clip((t-20)/20,0,1))[:,:,:3]*255).astype(np.uint8)

# ================= STATE =================
frame_id = 0
fps_t = time.time()
pig_behaviors = {}

INTERVAL_SEC = interval_seconds(INTERVAL_MODE, INTERVAL_VALUE)
THERMAL_READ_INTERVAL = INTERVAL_SEC
last_detection_time = time.time()

os.makedirs(SAVE_ROOT, exist_ok=True)

# ================= STARTUP TEST SAVE =================
startup_frame = picam2.capture_array()
startup_frame = cv2.flip(startup_frame, 0)

date = time.strftime("%Y-%m-%d")
tstamp = time.strftime("%H-%M-%S")

startup_dir = os.path.join(SAVE_ROOT, date)
os.makedirs(startup_dir, exist_ok=True)

startup_path = os.path.join(startup_dir, f"STARTUP_TEST_{tstamp}.jpg")
cv2.imwrite(startup_path, startup_frame)

print(f"[STARTUP TEST SAVED] {startup_path}")
ASF_DETECTED =  False
# ================= STREAM SERVER (CLEAN) =================
app = Flask(__name__)

latest_frame = None
frame_lock = threading.Lock()


def generate_stream():
    global latest_frame
    while True:
        with frame_lock:
            frame = latest_frame

            if frame is None:
                time.sleep(0.3)
                continue

            ret, jpeg = cv2.imencode(".jpg", frame)
            if not ret:
                continue

            yield (
                b"--frame\r\n"
                b"Content-Type: image/jpeg\r\n\r\n"
                + jpeg.tobytes()
                + b"\r\n"
            )


@app.route("/video")
def video():
    return Response(
        generate_stream(),
        mimetype="multipart/x-mixed-replace; boundary=frame"
    )


def start_stream_server():
    app.run(host="0.0.0.0", port=8080, threaded=True)


threading.Thread(
    target=start_stream_server,
    daemon=True
).start()

def thermal_loop():
    global cached_thermal_resized

    while True:
        if THERMAL_AVAILABLE:
            tdata = read_thermal()
            if tdata is not None:
                rgb = thermal_to_rgb(tdata)

                rgb = cv2.resize(rgb, (640, 480))
                rgb = cv2.flip(rgb, 0)
                draw_thermal_legend(rgb)

                with thermal_lock:
                    cached_thermal_resized = rgb

        time.sleep(10)

threading.Thread(target=thermal_loop, daemon=True).start()

# ================= MAIN LOOP =================
while True:
    frame = cv2.flip(picam2.capture_array(), 0)
    frame_id += 1
    H, W, _ = frame.shape


    detect_frame = frame.copy()
    pigs = []
    humans = []

    if LIVE_PIG_INFERENCE:

        small = cv2.resize(frame, (SMALL_W, int(H * SMALL_W / W)))
        sx, sy = W / small.shape[1], H / small.shape[0]

        pig_itp.set_tensor(pig_in[0]['index'], preprocess(small))
        pig_itp.invoke()
        preds = pig_itp.get_tensor(pig_out[0]['index'])[0].T

        for d in preds:
            x,y,bw,bh = d[:4]
            scores = d[4:]
            cid = int(np.argmax(scores))
            conf = float(scores[cid])
            if conf < PIG_CONF: continue

            x1 = int((x-bw/2)*small.shape[1]*sx)
            y1 = int((y-bh/2)*small.shape[0]*sy)
            x2 = int((x+bw/2)*small.shape[1]*sx)
            y2 = int((y+bh/2)*small.shape[0]*sy)

            if cid == PIG_CLASS_ID:
                pigs.append(((x1,y1,x2,y2), conf))
            elif cid == HUMAN_CLASS_ID:
                humans.append((x1,y1,x2,y2))

        pigs = nms_pig(pigs, 0.4)

    if LIVE_PIG_INFERENCE:

        for (x1,y1,x2,y2), conf in pigs:

            if LIVE_BEHAVIOR_INFERENCE:
                roi = detect_frame[y1:y2, x1:x2]
                if roi.size != 0:
                    pid = pig_id((x1,y1,x2,y2))
                    if pid not in pig_behaviors or frame_id - pig_behaviors[pid][1] >= BEHAVIOR_INTERVAL:
                        beh_itp.set_tensor(beh_in[0]['index'], preprocess(roi))
                        beh_itp.invoke()
                        o = beh_itp.get_tensor(beh_out[0]['index'])[0].T
                        behavior = BEHAVIOR_NAMES[int(np.argmax(max(o, key=lambda d:max(d[4:]))[4:]))]
                        pig_behaviors[pid] = (behavior, frame_id)
                label = pig_behaviors.get(pid, ("",))[0]
            else:
                label = ""

            cv2.rectangle(detect_frame,(x1,y1),(x2,y2),(0,255,0),2)
            cv2.putText(detect_frame,f"PIG {conf:.2f} {label}",
                        (x1,y1-6),cv2.FONT_HERSHEY_SIMPLEX,0.45,(0,255,0),1)

            if LIVE_SKIN_INFERENCE:
                pw, ph = int((x2-x1)*ROI_PAD), int((y2-y1)*ROI_PAD)
                px1, py1 = max(0,x1-pw), max(0,y1-ph)
                px2, py2 = min(W,x2+pw), min(H,y2+ph)

                skin_roi = detect_frame[py1:py2, px1:px2]
                if skin_roi.size != 0:
                    skin_itp.set_tensor(skin_in[0]['index'], preprocess(skin_roi))
                    skin_itp.invoke()
                    outs = skin_itp.get_tensor(skin_out[0]['index'])[0].T

                    dets=[]
                    for d in outs:
                        x,y,bw,bh = d[:4]
                        scores=d[4:]
                        cid=int(np.argmax(scores))
                        conf=float(scores[cid])
                        if (cid==1 and conf<LESION_CONF) or (cid==2 and conf<REDNESS_CONF): continue
                        if cid not in SKIN_NAMES: continue

                        rx1=int(px1+(x-bw/2)*(px2-px1))
                        ry1=int(py1+(y-bh/2)*(py2-py1))
                        rx2=int(px1+(x+bw/2)*(px2-px1))
                        ry2=int(py1+(y+bh/2)*(py2-py1))
                        if overlaps_any((rx1,ry1,rx2,ry2), humans): continue

                        dets.append(((rx1,ry1,rx2,ry2),conf,cid))

                    for (bx1,by1,bx2,by2),conf,cid in nms_skin(dets,0.45):
                        ASF_DETECTED = True
                        cv2.rectangle(detect_frame,(bx1,by1),(bx2,by2),(0,0,255),2)
                        cv2.putText(detect_frame,f"{SKIN_NAMES[cid]} {conf:.2f}",
                                    (bx1,by1-4),cv2.FONT_HERSHEY_SIMPLEX,0.4,(0,0,255),1)

    with thermal_lock:
        thermal_img = cached_thermal_resized

    if thermal_img is not None:
        preview = cv2.hconcat([detect_frame, thermal_img])
    else:
        preview = detect_frame


    now=time.time()
    PI_CAM_FPS=1.0/max(1e-6,now-fps_t)
    fps_t=now

    cv2.putText(preview,f"Pi FPS: {PI_CAM_FPS:.1f}",(10,30),
            cv2.FONT_HERSHEY_SIMPLEX,0.6,(0,255,255),2)
    cv2.putText(preview,f"Avg Temp: {THERMAL_AVG_TEMP:.1f} C",(10,55),
            cv2.FONT_HERSHEY_SIMPLEX,0.6,(0,180,255),2)

    print_countdown(last_detection_time, INTERVAL_SEC)
    draw_metadata_bar(preview)
    with frame_lock:
            h, w, _ = preview.shape
            scale = 960 / w
            stream_frame = cv2.resize(preview, (960, int(h * scale)))
            latest_frame = stream_frame

    #if SHOW_OPENCV_WINDOW:
        #cv2.imshow("ASF PI - Idle Mode", preview)


    #if cv2.waitKey(1)==27:
        #break

    loop_now = time.time()
    if (loop_now - last_detection_time) >= INTERVAL_SEC:

        LIVE_PIG_INFERENCE = True
        LIVE_BEHAVIOR_INFERENCE = True
        LIVE_SKIN_INFERENCE = True

        detect_frame = run_full_inference(frame)

        with thermal_lock:
            thermal_img = cached_thermal_resized

        if thermal_img is None:
            thermal_img = np.zeros_like(detect_frame)

        combined = cv2.hconcat([detect_frame, thermal_img])

        draw_metadata_bar(combined)

        date = time.strftime("%Y-%m-%d")
        tstamp = time.strftime("%H-%M-%S")

        save_dir = os.path.join(SAVE_ROOT, date)
        os.makedirs(save_dir, exist_ok=True)

        save_path = os.path.join(save_dir, f"{tstamp}.jpg")
        cv2.imwrite(save_path, combined)
        LIVE_PIG_INFERENCE = False
        LIVE_BEHAVIOR_INFERENCE = False
        LIVE_SKIN_INFERENCE = False

        cloud_url = upload_to_cloudinary(save_path, date)

        if cloud_url:
            hour_key = time.strftime("%H-00")
            farm_id = "farm_001"  # palitan later kung may auth na

            ref = db.reference(
                 f"farms/{farm_id}/detections/{date}/{hour_key}"
            )


            ref.push({

                "imageUrl": cloud_url,
                "avgTemp": round(THERMAL_AVG_TEMP, 1),
                "minTemp": round(THERMAL_MIN_TEMP, 1),
                "maxTemp": round(THERMAL_MAX_TEMP, 1),
                "asfDetected": ASF_DETECTED,
                "fever": THERMAL_AVG_TEMP >= SMS_TEMP_THRESHOLD,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
            })
          
        print(f"\n[SAVED RGB + THERMAL] {save_path}")
        last_detection_time = now

        # ================= SMS ALERTS =================
        if ASF_DETECTED or THERMAL_AVG_TEMP >= SMS_TEMP_THRESHOLD:
            gsm_init()

            if ASF_DETECTED:
                send_sms(
                    f"ASF ALERT!\n"
                    f"Lesion/Redness detected.\n"
                    f"Time: {date} {tstamp}"
                )

            if THERMAL_AVG_TEMP >= SMS_TEMP_THRESHOLD:
                send_sms(
                    f"TEMP ALERT!\n"
                    f"Avg Temp: {THERMAL_AVG_TEMP:.1f} C\n"
                    f"Time: {date} {tstamp}"
                )

            if gsm:
                gsm.close()
                gsm = None
                
    picam2.stop()
    #cv2.destroyAllWindows()

    if gsm:
        gsm.close()
