import cv2
import numpy as np
import time
import os
from tflite_runtime.interpreter import Interpreter
from picamera2 import Picamera2

# ================= THERMAL =================
try:
    import board
    import busio
    import adafruit_mlx90640
    from matplotlib import cm
    THERMAL_AVAILABLE = True
except Exception as e:
    print("Thermal not available:", e)
    THERMAL_AVAILABLE = False

# ================= PERFORMANCE =================
cv2.setNumThreads(0)
cv2.ocl.setUseOpenCL(False)

# ================= CONFIG =================
INPUT_SIZE = 416
SMALL_W = 320

INTERVAL_MODE = "minute"
INTERVAL_VALUE = 1
SAVE_ROOT = "/home/asfrotect/Desktop/detections"

PI_CAM_FPS = 0.0
THERMAL_AVG_TEMP = 0.0

# ================= LIVE INFERENCE SWITCHES =================
LIVE_PIG_INFERENCE = True
LIVE_BEHAVIOR_INFERENCE = False
LIVE_SKIN_INFERENCE = False

# ================= MODELS =================
PIG_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/PigvsNONPig-v2_float16.tflite"
BEHAVIOR_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/bestv8_behavior-2_float16.tflite"
SKIN_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/ASFskin_NoPartsv3_v8s.tflite"

PIG_CLASS_ID = 7
HUMAN_CLASS_ID = 0

PIG_CONF = 0.50
LESION_CONF = 0.10
REDNESS_CONF = 0.10

BEHAVIOR_INTERVAL = 12
ROI_PAD = 0.15

BEHAVIOR_NAMES = {
    0: "ACTIVE",
    1: "EATING",
    2: "GROUP",
    3: "INACTIVE"
}

SKIN_NAMES = {
    1: "ASF LESION",
    2: "REDNESS"
}

# ================= HELPERS =================
def preprocess(img):
    img = cv2.resize(img, (INPUT_SIZE, INPUT_SIZE))
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    return (img.astype(np.float32) / 255.0)[None]

def compute_iou(a, b):
    xA, yA = max(a[0], b[0]), max(a[1], b[1])
    xB, yB = min(a[2], b[2]), min(a[3], b[3])
    inter = max(0, xB - xA) * max(0, yB - yA)
    areaA = max(0, a[2]-a[0]) * max(0, a[3]-a[1])
    areaB = max(0, b[2]-b[0]) * max(0, b[3]-b[1])
    return inter / (areaA + areaB - inter + 1e-6)

def nms_pig(dets, thr):
    dets = sorted(dets, key=lambda x: x[1], reverse=True)
    out = []
    while dets:
        best = dets.pop(0)
        out.append(best)
        dets = [d for d in dets if compute_iou(best[0], d[0]) < thr]
    return out

def nms_skin(dets, thr):
    dets = sorted(dets, key=lambda x: x[1], reverse=True)
    out = []
    while dets:
        best = dets.pop(0)
        out.append(best)
        dets = [d for d in dets if compute_iou(best[0], d[0]) < thr or best[2] != d[2]]
    return out

def overlaps_any(box, boxes, thr=0.25):
    return any(compute_iou(box, b) > thr for b in boxes)

def pig_id(box):
    x1, y1, x2, y2 = box
    return (x1//30, y1//30, x2//30, y2//30)

def interval_seconds(mode, value):
    return value * 60 if mode == "minute" else value * 3600

def print_countdown(last_time, interval_sec):
    remaining = int(interval_sec - (time.time() - last_time))
    remaining = max(0, remaining)
    m, s = divmod(remaining, 60)
    print(f"\rNext capture in: {m:02d}:{s:02d}", end="")

# ================= THERMAL LEGEND =================
def draw_thermal_legend(img, tmin=20.0, tmax=40.0):
    h, w, _ = img.shape
    bar_w, pad_x = 20, 10
    y1, y2 = 50, h - 60
    x1, x2 = w - bar_w - pad_x, w - pad_x

    for i in range(y1, y2):
        ratio = 1.0 - (i - y1) / (y2 - y1)
        temp = tmin + ratio * (tmax - tmin)
        norm = (temp - tmin) / (tmax - tmin)
        bgr = tuple(int(c * 255) for c in reversed(cm.inferno(norm)[:3]))
        cv2.line(img, (x1, i), (x2, i), bgr, 1)

    cv2.rectangle(img, (x1, y1), (x2, y2), (255,255,255), 1)

    for temp, y in [(tmax, y1+14), (tmin, y2-6)]:
        label = f"{int(temp)} C"
        (tw, _), _ = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.45, 1)
        cv2.putText(img, label, (x1 - tw - 8, y),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.45, (255,255,255), 1)

# ================= LOAD MODELS =================
def load_model(path):
    itp = Interpreter(model_path=path, num_threads=4)
    itp.allocate_tensors()
    return itp

pig_itp = load_model(PIG_MODEL)
beh_itp = load_model(BEHAVIOR_MODEL)
skin_itp = load_model(SKIN_MODEL)

pig_in, pig_out = pig_itp.get_input_details(), pig_itp.get_output_details()
beh_in, beh_out = beh_itp.get_input_details(), beh_itp.get_output_details()
skin_in, skin_out = skin_itp.get_input_details(), skin_itp.get_output_details()

# ================= CAMERA =================
picam2 = Picamera2()
picam2.configure(picam2.create_preview_configuration(
    main={"format": "RGB888", "size": (640, 480)}
))
picam2.start()

# ================= THERMAL INIT =================
if THERMAL_AVAILABLE:
    i2c = busio.I2C(board.SCL, board.SDA)
    mlx90640 = adafruit_mlx90640.MLX90640(i2c)
    mlx90640.refresh_rate = adafruit_mlx90640.RefreshRate.REFRESH_4_HZ
    thermal_frame = np.zeros((24 * 32,), dtype=float)

THERMAL_READ_INTERVAL = 0.5
last_thermal_time = 0
cached_thermal_rgb = None

def read_thermal():
    global THERMAL_AVG_TEMP
    try:
        mlx90640.getFrame(thermal_frame)
        data = thermal_frame.reshape((24, 32))
        THERMAL_AVG_TEMP = float(np.mean(data))
        return data
    except RuntimeError as e:
        print(f"[THERMAL WARNING] {e}")
        return None

def thermal_to_rgb(t):
    return (cm.inferno(np.clip((t-20)/20,0,1))[:,:,:3]*255).astype(np.uint8)

# ================= STATE =================
frame_id = 0
fps_t = time.time()
pig_behaviors = {}

INTERVAL_SEC = interval_seconds(INTERVAL_MODE, INTERVAL_VALUE)
last_detection_time = time.time()

os.makedirs(SAVE_ROOT, exist_ok=True)

# ================= STARTUP TEST SAVE =================
startup_frame = picam2.capture_array()
startup_frame = cv2.flip(startup_frame, 0)

date = time.strftime("%Y-%m-%d")
tstamp = time.strftime("%H-%M-%S")

startup_dir = os.path.join(SAVE_ROOT, date)
os.makedirs(startup_dir, exist_ok=True)

startup_path = os.path.join(startup_dir, f"STARTUP_TEST_{tstamp}.jpg")
cv2.imwrite(startup_path, startup_frame)

print(f"[STARTUP TEST SAVED] {startup_path}")

# ================= MAIN LOOP =================
while True:
    frame = cv2.flip(picam2.capture_array(), 0)
    frame_id += 1
    H, W, _ = frame.shape

    if THERMAL_AVAILABLE and time.time() - last_thermal_time >= THERMAL_READ_INTERVAL:
        tdata = read_thermal()
        if tdata is not None:
            cached_thermal_rgb = thermal_to_rgb(tdata)
        last_thermal_time = time.time()

    detect_frame = frame.copy()
    pigs = []
    humans = []

    if LIVE_PIG_INFERENCE:
        small = cv2.resize(frame, (SMALL_W, int(H * SMALL_W / W)))
        sx, sy = W / small.shape[1], H / small.shape[0]

        pig_itp.set_tensor(pig_in[0]['index'], preprocess(small))
        pig_itp.invoke()
        preds = pig_itp.get_tensor(pig_out[0]['index'])[0].T

        for d in preds:
            x,y,bw,bh = d[:4]
            scores = d[4:]
            cid = int(np.argmax(scores))
            conf = float(scores[cid])
            if conf < PIG_CONF: continue

            x1 = int((x-bw/2)*small.shape[1]*sx)
            y1 = int((y-bh/2)*small.shape[0]*sy)
            x2 = int((x+bw/2)*small.shape[1]*sx)
            y2 = int((y+bh/2)*small.shape[0]*sy)

            if cid == PIG_CLASS_ID:
                pigs.append(((x1,y1,x2,y2), conf))
            elif cid == HUMAN_CLASS_ID:
                humans.append((x1,y1,x2,y2))

        pigs = nms_pig(pigs, 0.4)

    if LIVE_PIG_INFERENCE:
        for (x1,y1,x2,y2), conf in pigs:

            if LIVE_BEHAVIOR_INFERENCE:
                roi = detect_frame[y1:y2, x1:x2]
                if roi.size != 0:
                    pid = pig_id((x1,y1,x2,y2))
                    if pid not in pig_behaviors or frame_id - pig_behaviors[pid][1] >= BEHAVIOR_INTERVAL:
                        beh_itp.set_tensor(beh_in[0]['index'], preprocess(roi))
                        beh_itp.invoke()
                        o = beh_itp.get_tensor(beh_out[0]['index'])[0].T
                        behavior = BEHAVIOR_NAMES[int(np.argmax(max(o, key=lambda d:max(d[4:]))[4:]))]
                        pig_behaviors[pid] = (behavior, frame_id)
                label = pig_behaviors.get(pid, ("",))[0]
            else:
                label = ""

            cv2.rectangle(detect_frame,(x1,y1),(x2,y2),(0,255,0),2)
            cv2.putText(detect_frame,f"PIG {conf:.2f} {label}",
                        (x1,y1-6),cv2.FONT_HERSHEY_SIMPLEX,0.45,(0,255,0),1)

            if LIVE_SKIN_INFERENCE:
                pw, ph = int((x2-x1)*ROI_PAD), int((y2-y1)*ROI_PAD)
                px1, py1 = max(0,x1-pw), max(0,y1-ph)
                px2, py2 = min(W,x2+pw), min(H,y2+ph)

                skin_roi = detect_frame[py1:py2, px1:px2]
                if skin_roi.size != 0:
                    skin_itp.set_tensor(skin_in[0]['index'], preprocess(skin_roi))
                    skin_itp.invoke()
                    outs = skin_itp.get_tensor(skin_out[0]['index'])[0].T

                    dets=[]
                    for d in outs:
                        x,y,bw,bh = d[:4]
                        scores=d[4:]
                        cid=int(np.argmax(scores))
                        conf=float(scores[cid])
                        if (cid==1 and conf<LESION_CONF) or (cid==2 and conf<REDNESS_CONF): continue
                        if cid not in SKIN_NAMES: continue

                        rx1=int(px1+(x-bw/2)*(px2-px1))
                        ry1=int(py1+(y-bh/2)*(py2-py1))
                        rx2=int(px1+(x+bw/2)*(px2-px1))
                        ry2=int(py1+(y+bh/2)*(py2-py1))
                        if overlaps_any((rx1,ry1,rx2,ry2), humans): continue

                        dets.append(((rx1,ry1,rx2,ry2),conf,cid))

                    for (bx1,by1,bx2,by2),conf,cid in nms_skin(dets,0.45):
                        cv2.rectangle(detect_frame,(bx1,by1),(bx2,by2),(0,0,255),2)
                        cv2.putText(detect_frame,f"{SKIN_NAMES[cid]} {conf:.2f}",
                                    (bx1,by1-4),cv2.FONT_HERSHEY_SIMPLEX,0.4,(0,0,255),1)

    if cached_thermal_rgb is not None:
        tprev=cv2.resize(cached_thermal_rgb,(W,H))
        tprev=cv2.flip(tprev,0)
        draw_thermal_legend(tprev)
        preview=cv2.hconcat([detect_frame,tprev])
    else:
        preview=detect_frame.copy()

    now=time.time()
    PI_CAM_FPS=1.0/max(1e-6,now-fps_t)
    fps_t=now

    cv2.putText(preview,f"Pi FPS: {PI_CAM_FPS:.1f}",(10,30),
                cv2.FONT_HERSHEY_SIMPLEX,0.6,(0,255,255),2)
    cv2.putText(preview,f"Avg Temp: {THERMAL_AVG_TEMP:.1f} C",(10,55),
                cv2.FONT_HERSHEY_SIMPLEX,0.6,(0,180,255),2)

    print_countdown(last_detection_time, INTERVAL_SEC)
    cv2.imshow("ASF PI - Idle Mode", preview)

    if cv2.waitKey(1)==27:
        break

    now = time.time()
    if (now - last_detection_time) >= INTERVAL_SEC:
        if cached_thermal_rgb is not None:
            thermal_rgb = cv2.resize(cached_thermal_rgb, (detect_frame.shape[1], detect_frame.shape[0]))
            thermal_rgb = cv2.flip(thermal_rgb, 0)
            draw_thermal_legend(thermal_rgb)
        else:
            thermal_rgb = np.zeros_like(detect_frame)

        combined = cv2.hconcat([detect_frame, thermal_rgb])

        date = time.strftime("%Y-%m-%d")
        tstamp = time.strftime("%H-%M-%S")

        save_dir = os.path.join(SAVE_ROOT, date)
        os.makedirs(save_dir, exist_ok=True)

        save_path = os.path.join(save_dir, f"{tstamp}.jpg")
        cv2.imwrite(save_path, combined)

        print(f"\n[SAVED RGB + THERMAL] {save_path}")
        last_detection_time = now

picam2.stop()
cv2.destroyAllWindows()
