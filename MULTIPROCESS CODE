import cv2
import numpy as np
import time
from tflite_runtime.interpreter import Interpreter
from picamera2 import Picamera2

# ================= CONFIG =================
PIG_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/PigvsNonPig.320.v3_v8s.tflite"
BEHAVIOR_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/Behavior.320.v8_v8s.tflite"
SKIN_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/ASFskin_NoPartsv3_v8s.tflite"

PIG_SIZE = 320
BEH_SIZE = 320
SKIN_SIZE = 416

PIG_CONF = 0.45
BEH_CONF = 0.40
SKIN_CONF = 0.35

PIG_IOU = 0.40
SKIN_IOU = 0.25

SKIP_PIG = 3
SKIP_BEH = 6
SKIP_SKIN = 8

SKIN_HOLD_FRAMES = 7

PIG_CLASS_ID = 7

# ================= LABELS =================
BEHAVIOR_NAMES = {
    0: "ACTIVE",
    1: "EATING",
    2: "GROUP",
    3: "INACTIVE"
}

SKIN_NAMES = {
    1: "ASF LESION",
    2: "REDNESS"
}

# ================= HELPERS =================
def preprocess(img, size):
    img = cv2.resize(img, (size, size))
    img = img.astype(np.float32) / 255.0
    return img[np.newaxis, ...]

def compute_iou(a, b):
    xA, yA = max(a[0], b[0]), max(a[1], b[1])
    xB, yB = min(a[2], b[2]), min(a[3], b[3])
    inter = max(0, xB - xA) * max(0, yB - yA)
    areaA = max(0, a[2]-a[0]) * max(0, a[3]-a[1])
    areaB = max(0, b[2]-b[0]) * max(0, b[3]-b[1])
    return inter / (areaA + areaB - inter + 1e-6)

def nms(dets, thresh):
    dets = sorted(dets, key=lambda x: x[1], reverse=True)
    keep = []
    while dets:
        best = dets.pop(0)
        keep.append(best)
        dets = [d for d in dets if compute_iou(best[0], d[0]) < thresh]
    return keep

def load_model(path):
    itp = Interpreter(model_path=path, num_threads=4)
    itp.allocate_tensors()
    return itp

# ================= LOAD MODELS =================
pig_itp = load_model(PIG_MODEL)
beh_itp = load_model(BEHAVIOR_MODEL)
skin_itp = load_model(SKIN_MODEL)

pig_in, pig_out = pig_itp.get_input_details(), pig_itp.get_output_details()
beh_in, beh_out = beh_itp.get_input_details(), beh_itp.get_output_details()
skin_in, skin_out = skin_itp.get_input_details(), skin_itp.get_output_details()

# ================= CAMERA =================
picam2 = Picamera2()
config = picam2.create_preview_configuration(
    main={"format": "RGB888", "size": (640, 480)}
)
picam2.configure(config)
picam2.start()

frame_id = 0
fps_time = time.time()
fps_buffer = []
FPS_WINDOW = 20

last_pigs = []
last_behavior = {}
skin_memory = []

# ================= MAIN LOOP =================
while True:
    frame = picam2.capture_array()          # RGB frame
    frame_bgr = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)  # for display

    frame_id += 1
    H, W, _ = frame.shape

    # -------- PIG DETECTION --------
    if frame_id % SKIP_PIG == 0:
        pig_itp.set_tensor(
            pig_in[0]['index'],
            preprocess(frame.copy(), PIG_SIZE)
        )
        pig_itp.invoke()
        preds = pig_itp.get_tensor(pig_out[0]['index'])[0].T

        pigs = []
        for d in preds:
            x, y, bw, bh = d[:4]
            scores = d[4:]
            cid = int(np.argmax(scores))
            conf = float(scores[cid])

            if cid != PIG_CLASS_ID or conf < PIG_CONF:
                continue

            x1 = int((x - bw/2) * W)
            y1 = int((y - bh/2) * H)
            x2 = int((x + bw/2) * W)
            y2 = int((y + bh/2) * H)

            pigs.append(((x1,y1,x2,y2), conf))

        last_pigs = nms(pigs, PIG_IOU)

    # -------- PER PIG --------
    for (x1,y1,x2,y2), pconf in last_pigs:
        roi = frame[max(0,y1):min(H,y2), max(0,x1):min(W,x2)]
        if roi.size == 0:
            continue

        pid = (x1,y1,x2,y2)

        if frame_id % SKIP_BEH == 0:
            beh_itp.set_tensor(
                beh_in[0]['index'],
                preprocess(roi.copy(), BEH_SIZE)
            )
            beh_itp.invoke()
            out = beh_itp.get_tensor(beh_out[0]['index'])[0].T
            best = max(out, key=lambda d: max(d[4:]))
            last_behavior[pid] = BEHAVIOR_NAMES[int(np.argmax(best[4:]))]

        label = last_behavior.get(pid, "…")

        if frame_id % SKIP_SKIN == 0:
            skin_itp.set_tensor(
                skin_in[0]['index'],
                preprocess(roi.copy(), SKIN_SIZE)
            )
            skin_itp.invoke()
            outs = skin_itp.get_tensor(skin_out[0]['index'])[0].T

            for d in outs:
                sx, sy, sw, sh = d[:4]
                scores = d[4:]
                cid = int(np.argmax(scores))
                conf = float(scores[cid])

                if cid not in SKIN_NAMES or conf < SKIN_CONF:
                    continue

                bx1 = int(x1 + (sx - sw/2) * (x2-x1))
                by1 = int(y1 + (sy - sh/2) * (y2-y1))
                bx2 = int(x1 + (sx + sw/2) * (x2-x1))
                by2 = int(y1 + (sy + sh/2) * (y2-y1))

                skin_memory.append([(bx1,by1,bx2,by2), conf, cid, SKIN_HOLD_FRAMES])

        cv2.rectangle(frame_bgr,(x1,y1),(x2,y2),(0,255,0),2)
        cv2.putText(frame_bgr,
            f"PIG {pconf:.2f} | {label}",
            (x1, max(0,y1-6)),
            cv2.FONT_HERSHEY_SIMPLEX, 0.45, (0,255,0), 1)

    # -------- DRAW SKIN MEMORY --------
    updated = []
    for box, conf, cid, ttl in skin_memory:
        if ttl <= 0:
            continue
        x1,y1,x2,y2 = box
        cv2.rectangle(frame_bgr,(x1,y1),(x2,y2),(0,0,255),2)
        cv2.putText(frame_bgr,
            f"{SKIN_NAMES[cid]} {conf:.2f}",
            (x1,y1-4),
            cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0,0,255), 1)
        updated.append([box, conf, cid, ttl-1])
    skin_memory = updated

    # -------- FPS --------
    now = time.time()
    fps_buffer.append(1.0 / max(now - fps_time, 1e-6))
    fps_time = now
    if len(fps_buffer) > FPS_WINDOW:
        fps_buffer.pop(0)

    cv2.putText(frame_bgr, f"FPS: {sum(fps_buffer)/len(fps_buffer):.2f}",
                (10,30), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,255), 2)

    cv2.imshow("ASF – PI FINAL PIPELINE", frame_bgr)
    if cv2.waitKey(1) == 27:
        break

picam2.stop()
cv2.destroyAllWindows()
