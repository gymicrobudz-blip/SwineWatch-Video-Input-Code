# ================= FULL CODE (MERGED PROPERLY) =================
# nothing unrelated removed

import cv2
import numpy as np
import time
import os
from tflite_runtime.interpreter import Interpreter
from picamera2 import Picamera2

# ================= THERMAL (OPTIONAL) =================
try:
    import board
    import busio
    import adafruit_mlx90640
    from matplotlib import cm
    THERMAL_AVAILABLE = True
except Exception as e:
    print("Thermal not available:", e)
    THERMAL_AVAILABLE = False

# ================= PERFORMANCE =================
cv2.setNumThreads(0)
cv2.ocl.setUseOpenCL(False)

# ================= INTERVAL CONFIG =================
INTERVAL_MODE = "minute"
INTERVAL_VALUE = 1
SAVE_ROOT = "/home/asfrotect/Desktop/detections"

# ================= CONFIG =================
INPUT_SIZE = 416
SMALL_W = 320

PI_CAM_FPS = 0.0
THERMAL_AVG_TEMP = 0.0

PIG_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/PigvsNONPig-v2_float16.tflite"
BEHAVIOR_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/bestv8_behavior-2_float16.tflite"
SKIN_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/ASFskin_NoPartsv3_v8s.tflite"

PIG_CLASS_ID = 7
HUMAN_CLASS_ID = 0

PIG_CONF = 0.50
LESION_CONF = 0.1
REDNESS_CONF = 0.1

BEHAVIOR_INTERVAL = 12
ROI_PAD = 0.15

# ================= LABELS =================
BEHAVIOR_NAMES = {
    0: "ACTIVE",
    1: "EATING",
    2: "GROUP",
    3: "INACTIVE"
}

SKIN_NAMES = {
    1: "ASF LESION",
    2: "REDNESS"
}

# ================= HELPERS =================
def preprocess(img):
    img = cv2.resize(img, (INPUT_SIZE, INPUT_SIZE))
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    return (img.astype(np.float32) / 255.0)[None]

def compute_iou(a, b):
    xA, yA = max(a[0], b[0]), max(a[1], b[1])
    xB, yB = min(a[2], b[2]), min(a[3], b[3])
    inter = max(0, xB - xA) * max(0, yB - yA)
    areaA = max(0, a[2]-a[0]) * max(0, a[3]-a[1])
    areaB = max(0, b[2]-b[0]) * max(0, b[3]-b[1])
    return inter / (areaA + areaB - inter + 1e-6)

def nms_pig(dets, thr):
    dets = sorted(dets, key=lambda x: x[1], reverse=True)
    out = []
    while dets:
        best = dets.pop(0)
        out.append(best)
        dets = [d for d in dets if compute_iou(best[0], d[0]) < thr]
    return out

def nms_skin(dets, thr):
    dets = sorted(dets, key=lambda x: x[1], reverse=True)
    out = []
    while dets:
        best = dets.pop(0)
        out.append(best)
        dets = [d for d in dets if compute_iou(best[0], d[0]) < thr or best[2] != d[2]]
    return out

def overlaps_any(box, boxes, thr=0.25):
    return any(compute_iou(box, b) > thr for b in boxes)

def pig_id(box):
    x1, y1, x2, y2 = box
    return (x1//30, y1//30, x2//30, y2//30)

def load_model(path):
    itp = Interpreter(model_path=path, num_threads=4)
    itp.allocate_tensors()
    return itp

def interval_seconds(mode, value):
    return value * 60 if mode == "minute" else value * 3600

def print_countdown(last_time, interval_sec):
    remaining = max(0, int(interval_sec - (time.time() - last_time)))
    m, s = divmod(remaining, 60)
    print(f"\rNext capture in: {m:02d}:{s:02d}", end="")

# ================= MODELS =================
pig_itp = load_model(PIG_MODEL)
beh_itp = load_model(BEHAVIOR_MODEL)
skin_itp = load_model(SKIN_MODEL)

pig_in, pig_out = pig_itp.get_input_details(), pig_itp.get_output_details()
beh_in, beh_out = beh_itp.get_input_details(), beh_itp.get_output_details()
skin_in, skin_out = skin_itp.get_input_details(), skin_itp.get_output_details()

# ================= CAMERA =================
picam2 = Picamera2()
picam2.configure(picam2.create_preview_configuration(
    main={"format": "RGB888", "size": (640, 480)}
))
picam2.start()

# ================= STATE =================
frame_id = 0
fps_t = time.time()
pig_behaviors = {}

INTERVAL_SEC = interval_seconds(INTERVAL_MODE, INTERVAL_VALUE)
last_detection_time = time.time()

# ================= MAIN LOOP =================
while True:
    frame = cv2.flip(picam2.capture_array(), 0)
    frame_id += 1   # ðŸ”§ FIXED (FROM CODE 1)

    H, W, _ = frame.shape

    # ================= INTERVAL TRIGGER =================
    now = time.time()
    if (now - last_detection_time) >= INTERVAL_SEC:

        # ===== PIG DETECTION (CODE 1) =====
        small = cv2.resize(frame, (SMALL_W, int(H * SMALL_W / W)))
        sx, sy = W / small.shape[1], H / small.shape[0]

        pig_itp.set_tensor(pig_in[0]['index'], preprocess(small))
        pig_itp.invoke()
        preds = pig_itp.get_tensor(pig_out[0]['index'])[0].T

        pigs, humans = [], []

        for d in preds:
            x, y, bw, bh = d[:4]
            scores = d[4:]
            cid = int(np.argmax(scores))
            conf = float(scores[cid])
            if conf < PIG_CONF:
                continue

            x1 = int((x - bw/2) * small.shape[1] * sx)
            y1 = int((y - bh/2) * small.shape[0] * sy)
            x2 = int((x + bw/2) * small.shape[1] * sx)
            y2 = int((y + bh/2) * small.shape[0] * sy)

            if cid == PIG_CLASS_ID:
                pigs.append(((x1, y1, x2, y2), conf))
            elif cid == HUMAN_CLASS_ID:
                humans.append((x1, y1, x2, y2))

        pigs = nms_pig(pigs, 0.4)

        # ===== BEHAVIOR + SKIN (CODE 1) =====
        if pigs:
            for (x1, y1, x2, y2), conf in pigs:
                pid = pig_id((x1, y1, x2, y2))
                roi = frame[y1:y2, x1:x2]
                if roi.size == 0:
                    continue

                if pid not in pig_behaviors or frame_id - pig_behaviors[pid][1] >= BEHAVIOR_INTERVAL:
                    beh_itp.set_tensor(beh_in[0]['index'], preprocess(roi))
                    beh_itp.invoke()
                    o = beh_itp.get_tensor(beh_out[0]['index'])[0].T
                    behavior = BEHAVIOR_NAMES[int(np.argmax(max(o, key=lambda d: max(d[4:]))[4:]))]
                    pig_behaviors[pid] = (behavior, frame_id)

                cv2.rectangle(frame, (x1,y1),(x2,y2),(0,255,0),2)
                cv2.putText(frame, f"PIG {conf:.2f} | {pig_behaviors[pid][0]}",
                            (x1,y1-6), cv2.FONT_HERSHEY_SIMPLEX, 0.45, (0,255,0), 1)

                # ---- SKIN ----
                pw = int((x2 - x1) * ROI_PAD)
                ph = int((y2 - y1) * ROI_PAD)

                px1 = max(0, x1 - pw)
                py1 = max(0, y1 - ph)
                px2 = min(W, x2 + pw)
                py2 = min(H, y2 + ph)

                skin_roi = frame[py1:py2, px1:px2]
                if skin_roi.size == 0:
                    continue

                skin_itp.set_tensor(skin_in[0]['index'], preprocess(skin_roi))
                skin_itp.invoke()
                outs = skin_itp.get_tensor(skin_out[0]['index'])[0].T

                dets = []
                for d in outs:
                    x, y, bw, bh = d[:4]
                    scores = d[4:]
                    cid = int(np.argmax(scores))
                    conf = float(scores[cid])

                    if cid == 1 and conf < LESION_CONF:
                        continue
                    if cid == 2 and conf < REDNESS_CONF:
                        continue
                    if cid not in SKIN_NAMES:
                        continue

                    rx1 = int(px1 + (x - bw/2) * (px2 - px1))
                    ry1 = int(py1 + (y - bh/2) * (py2 - py1))
                    rx2 = int(px1 + (x + bw/2) * (px2 - px1))
                    ry2 = int(py1 + (y + bh/2) * (py2 - py1))

                    if overlaps_any((rx1, ry1, rx2, ry2), humans):
                        continue

                    dets.append(((rx1, ry1, rx2, ry2), conf, cid))

                for (bx1, by1, bx2, by2), conf, cid in nms_skin(dets, 0.45):
                    cv2.rectangle(frame, (bx1, by1), (bx2, by2), (0,0,255), 2)
                    cv2.putText(frame, f"{SKIN_NAMES[cid]} {conf:.2f}",
                                (bx1, by1-4), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0,0,255), 1)

        last_detection_time = now

    cv2.imshow("ASF PI - Interval Mode", frame)
    if cv2.waitKey(1) == 27:
        break

picam2.stop()
cv2.destroyAllWindows()
