# ================= ASF THERMAL FINAL =================
import cv2
import numpy as np
import time
import os
from tflite_runtime.interpreter import Interpreter
from picamera2 import Picamera2

# ================= THERMAL =================
try:
    import board, busio, adafruit_mlx90640
    from matplotlib import cm
    THERMAL_AVAILABLE = True
except:
    THERMAL_AVAILABLE = False

# ================= PERFORMANCE =================
cv2.setNumThreads(0)
cv2.ocl.setUseOpenCL(False)

# ================= CONFIG =================
INPUT_SIZE = 416
SMALL_W = 320
ROI_PAD = 0.15

INTERVAL_MODE = "minute"
INTERVAL_VALUE = 1
SAVE_ROOT = "/home/asfrotect/Desktop/detections"

PIG_CONF = 0.50
LESION_CONF = 0.10
REDNESS_CONF = 0.10
BEHAVIOR_INTERVAL = 12

PIG_CLASS_ID = 7
HUMAN_CLASS_ID = 0

BEHAVIOR_NAMES = {0: "ACTIVE", 1: "EATING", 2: "GROUP", 3: "INACTIVE"}
SKIN_NAMES = {1: "ASF LESION", 2: "REDNESS"}

# ================= MODELS =================
PIG_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/PigvsNONPig-v2_float16.tflite"
BEHAVIOR_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/bestv8_behavior-2_float16.tflite"
SKIN_MODEL = "/home/asfrotect/Projects/BYMS - TFLITE 3 COMBINED/ASFskin_NoPartsv3_v8s.tflite"

# ================= HELPERS =================
def preprocess(img):
    img = cv2.resize(img, (INPUT_SIZE, INPUT_SIZE))
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    return (img.astype(np.float32) / 255.0)[None]

def compute_iou(a, b):
    xA, yA = max(a[0], b[0]), max(a[1], b[1])
    xB, yB = min(a[2], b[2]), min(a[3], b[3])
    inter = max(0, xB-xA) * max(0, yB-yA)
    areaA = max(0, a[2]-a[0]) * max(0, a[3]-a[1])
    areaB = max(0, b[2]-b[0]) * max(0, b[3]-b[1])
    return inter / (areaA + areaB - inter + 1e-6)

def nms(dets, thr):
    dets = sorted(dets, key=lambda x: x[1], reverse=True)
    out = []
    while dets:
        best = dets.pop(0)
        out.append(best)
        dets = [d for d in dets if compute_iou(best[0], d[0]) < thr]
    return out

def interval_seconds():
    return INTERVAL_VALUE * 60 if INTERVAL_MODE == "minute" else INTERVAL_VALUE * 3600

def draw_thermal_legend(img, tmin=20, tmax=40):
    h, w, _ = img.shape
    x1, x2 = w - 30, w - 10
    y1, y2 = 40, h - 40
    for i in range(y1, y2):
        r = 1 - (i - y1) / (y2 - y1)
        color = cm.inferno(r)[:3]
        cv2.line(img, (x1,i), (x2,i), tuple(int(c*255) for c in color[::-1]), 1)
    cv2.rectangle(img, (x1,y1), (x2,y2), (255,255,255), 1)

# ================= LOAD MODELS =================
def load(path):
    itp = Interpreter(model_path=path, num_threads=4)
    itp.allocate_tensors()
    return itp

pig_itp = load(PIG_MODEL)
beh_itp = load(BEHAVIOR_MODEL)
skin_itp = load(SKIN_MODEL)

pig_in, pig_out = pig_itp.get_input_details(), pig_itp.get_output_details()
beh_in, beh_out = beh_itp.get_input_details(), beh_itp.get_output_details()
skin_in, skin_out = skin_itp.get_input_details(), skin_itp.get_output_details()

# ================= CAMERA =================
picam2 = Picamera2()
picam2.configure(picam2.create_preview_configuration(
    main={"format":"RGB888","size":(640,480)}))
picam2.start()

# ================= THERMAL =================
if THERMAL_AVAILABLE:
    i2c = busio.I2C(board.SCL, board.SDA)
    mlx = adafruit_mlx90640.MLX90640(i2c)
    mlx.refresh_rate = adafruit_mlx90640.RefreshRate.REFRESH_4_HZ
    thermal_buf = np.zeros(768)
else:
    mlx = None

cached_thermal_rgb = None
THERMAL_AVG_TEMP = 0
last_thermal = 0

# ================= STARTUP SAVE =================
os.makedirs(SAVE_ROOT, exist_ok=True)
date = time.strftime("%Y-%m-%d")
os.makedirs(f"{SAVE_ROOT}/{date}", exist_ok=True)
startup = cv2.flip(picam2.capture_array(), 0)
cv2.imwrite(f"{SAVE_ROOT}/{date}/STARTUP.jpg", startup)

# ================= STATE =================
last_save = time.time()
last_behavior = {}
fps_t = time.time()

# ================= MAIN LOOP =================
while True:
    frame = cv2.flip(picam2.capture_array(), 0)
    H, W = frame.shape[:2]

    # ---------- THERMAL ----------
    if THERMAL_AVAILABLE and time.time() - last_thermal > 0.5:
        mlx.getFrame(thermal_buf)
        t = thermal_buf.reshape(24,32)
        THERMAL_AVG_TEMP = float(np.mean(t))
        heat = cm.inferno(np.clip((t-20)/20,0,1))[:,:,:3]
        cached_thermal_rgb = cv2.resize((heat*255).astype(np.uint8),(W,H))
        last_thermal = time.time()

    # ---------- PIG DETECTION ----------
    small = cv2.resize(frame, (SMALL_W, int(H * SMALL_W / W)))
    sx, sy = W/small.shape[1], H/small.shape[0]

    pig_itp.set_tensor(pig_in[0]['index'], preprocess(small))
    pig_itp.invoke()
    preds = pig_itp.get_tensor(pig_out[0]['index'])[0].T

    pigs = []
    for d in preds:
        x,y,bw,bh = d[:4]
        scores = d[4:]
        cid = int(np.argmax(scores))
        conf = float(scores[cid])
        if cid != PIG_CLASS_ID or conf < PIG_CONF:
            continue
        x1 = int((x-bw/2)*small.shape[1]*sx)
        y1 = int((y-bh/2)*small.shape[0]*sy)
        x2 = int((x+bw/2)*small.shape[1]*sx)
        y2 = int((y+bh/2)*small.shape[0]*sy)
        pigs.append(((x1,y1,x2,y2),conf))

    pigs = nms(pigs,0.4)

    # ---------- BEHAVIOR ----------
    for (x1,y1,x2,y2),conf in pigs:
        roi = frame[y1:y2,x1:x2]
        if roi.size == 0:
            continue
        pid = (x1//30,y1//30,x2//30,y2//30)
        if pid not in last_behavior or time.time()-last_behavior[pid][1] > BEHAVIOR_INTERVAL:
            beh_itp.set_tensor(beh_in[0]['index'], preprocess(roi))
            beh_itp.invoke()
            out = beh_itp.get_tensor(beh_out[0]['index'])[0]
            last_behavior[pid] = (BEHAVIOR_NAMES[int(np.argmax(out))], time.time())
        cv2.rectangle(frame,(x1,y1),(x2,y2),(0,255,0),2)
        cv2.putText(frame,f"PIG {conf:.2f} | {last_behavior[pid][0]}",
                    (x1,y1-6),cv2.FONT_HERSHEY_SIMPLEX,0.45,(0,255,0),1)

    # ---------- INTERVAL SKIN + SAVE ----------
    if pigs and time.time()-last_save >= interval_seconds():
        detect = frame.copy()
        for (x1,y1,x2,y2),_ in pigs:
            padw,padh = int((x2-x1)*ROI_PAD), int((y2-y1)*ROI_PAD)
            rx1,ry1 = max(0,x1-padw), max(0,y1-padh)
            rx2,ry2 = min(W,x2+padw), min(H,y2+padh)
            roi = detect[ry1:ry2,rx1:rx2]
            if roi.size == 0:
                continue
            skin_itp.set_tensor(skin_in[0]['index'], preprocess(roi))
            skin_itp.invoke()
            outs = skin_itp.get_tensor(skin_out[0]['index'])[0].T
            for d in outs:
                x,y,bw,bh = d[:4]
                scores = d[4:]
                cid = int(np.argmax(scores))
                conf = float(scores[cid])
                if cid not in SKIN_NAMES:
                    continue
                if cid==1 and conf<LESION_CONF: continue
                if cid==2 and conf<REDNESS_CONF: continue
                bx1 = int(rx1+(x-bw/2)*(rx2-rx1))
                by1 = int(ry1+(y-bh/2)*(ry2-ry1))
                bx2 = int(rx1+(x+bw/2)*(rx2-rx1))
                by2 = int(ry1+(y+bh/2)*(ry2-ry1))
                cv2.rectangle(detect,(bx1,by1),(bx2,by2),(0,0,255),2)
                cv2.putText(detect,f"{SKIN_NAMES[cid]} {conf:.2f}",
                            (bx1,by1-4),cv2.FONT_HERSHEY_SIMPLEX,0.4,(0,0,255),1)

        combined = cv2.hconcat([detect, cached_thermal_rgb]) if cached_thermal_rgb is not None else detect
        cv2.imwrite(f"{SAVE_ROOT}/{date}/{time.strftime('%H-%M-%S')}.jpg", combined)
        last_save = time.time()
        print("[SAVED]")

    # ---------- PREVIEW ----------
    preview = cv2.hconcat([frame, cached_thermal_rgb]) if cached_thermal_rgb is not None else frame
    draw_thermal_legend(preview)

    now = time.time()
    fps = 1/(now-fps_t)
    fps_t = now

    cv2.putText(preview,f"FPS:{fps:.1f}",(10,30),0,0.7,(0,255,255),2)
    cv2.putText(preview,f"T:{THERMAL_AVG_TEMP:.1f}C",(10,55),0,0.7,(0,180,255),2)

    cv2.imshow("ASF PI FINAL", preview)
    if cv2.waitKey(1)==27:
        break

picam2.stop()
cv2.destroyAllWindows()
